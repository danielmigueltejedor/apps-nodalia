#!/command/with-contenv bashio
# shellcheck shell=bash
# ==============================================================================
# Home Assistant App: Tailscale (Nodalia Beta)
# Support tunnel manager (temporary Cloudflare quick tunnel)
# ==============================================================================
set -euo pipefail

readonly PID_FILE="/run/support-tunnel.pid"
readonly STATE_FILE="/data/support-tunnel.json"
readonly LOG_FILE="/data/support-tunnel.log"
readonly META_FILE="/data/support-tunnel-meta.json"
readonly AUDIT_FILE="/data/support-tunnel-audit.log"
readonly URL_REGEX='https://[A-Za-z0-9.-]+\.trycloudflare\.com'
readonly STARTUP_WAIT_LOOPS=50
readonly STARTUP_WAIT_DELAY=0.2

now_utc() {
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

json_bool() {
  if [[ "${1:-false}" == "true" ]]; then
    echo "true"
  else
    echo "false"
  fi
}

normalize_dns_value() {
  local value
  value="${1:-}"
  value="$(printf '%s' "${value}" | tr '[:upper:]' '[:lower:]')"
  value="${value#.}"
  value="${value%.}"
  printf '%s' "${value}"
}

dns_matches_suffix() {
  local value suffix
  value="$(normalize_dns_value "${1:-}")"
  suffix="$(normalize_dns_value "${2:-}")"
  if [[ -z "${value}" || -z "${suffix}" ]]; then
    return 1
  fi
  [[ "${value}" == "${suffix}" || "${value}" == *".${suffix}" ]]
}

cloudflared_pid() {
  if [[ -f "${PID_FILE}" ]]; then
    cat "${PID_FILE}"
  fi
}

is_pid_running() {
  local pid
  pid="${1:-}"
  [[ -n "${pid}" ]] && kill -0 "${pid}" 2>/dev/null
}

extract_url() {
  if [[ -f "${LOG_FILE}" ]]; then
    grep -Eo "${URL_REGEX}" "${LOG_FILE}" | tail -n1 || true
  fi
}

audit_event() {
  local action reason url actor now
  action="${1:-unknown}"
  reason="${2:-}"
  url="${3:-}"
  actor="${SUPPORT_ACTOR:-ui}"
  now="$(now_utc)"
  jq -nc \
    --arg ts "${now}" \
    --arg action "${action}" \
    --arg reason "${reason}" \
    --arg url "${url}" \
    --arg actor "${actor}" \
    --arg target_id "${SUPPORT_TARGET_ID:-}" \
    --arg target_url "${SUPPORT_TARGET_URL:-}" \
    '{ts:$ts,action:$action,reason:$reason,url:$url,actor:$actor,target_id:$target_id,target_url:$target_url}' \
    >> "${AUDIT_FILE}"
}

read_meta() {
  META_EXPIRES_EPOCH=0
  META_EXPIRES_AT=""
  META_TTL_MIN=0
  if [[ -f "${META_FILE}" ]]; then
    META_EXPIRES_EPOCH="$(jq -r '.expires_epoch // 0' "${META_FILE}" 2>/dev/null || echo "0")"
    META_EXPIRES_AT="$(jq -r '.expires_at // empty' "${META_FILE}" 2>/dev/null || true)"
    META_TTL_MIN="$(jq -r '.ttl_minutes // 0' "${META_FILE}" 2>/dev/null || echo "0")"
  fi
}

write_meta() {
  local ttl now_epoch expires_epoch expires_at
  ttl="${1:-30}"
  now_epoch="$(date +%s)"
  expires_epoch=$((now_epoch + ttl * 60))
  expires_at="$(date -u -r "${expires_epoch}" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || true)"
  if [[ -z "${expires_at}" ]]; then
    expires_at="$(date -u -d "@${expires_epoch}" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || true)"
  fi
  jq -nc \
    --arg created_at "$(now_utc)" \
    --arg expires_at "${expires_at}" \
    --argjson expires_epoch "${expires_epoch}" \
    --argjson ttl_minutes "${ttl}" \
    '{created_at:$created_at,expires_at:$expires_at,expires_epoch:$expires_epoch,ttl_minutes:$ttl_minutes}' > "${META_FILE}"
}

build_eligibility() {
  local status_json support_enabled target_url backend candidate_strings
  local target_dns_suffix self_dns_name magic_dns_suffix token_lc
  support_enabled=false
  if bashio::config.has_value "support_tunnel_enabled" && bashio::config.true "support_tunnel_enabled"; then
    support_enabled=true
  fi

  # support_tailnet_id is kept for backward compatibility only.
  # Eligibility is based exclusively on DNS suffix matching.
  target_dns_suffix="$(normalize_dns_value "$(bashio::config "support_tailnet_dns_suffix" "tail37b857.ts.net")")"
  target_url="$(bashio::config "support_target_url" "http://127.0.0.1:8123")"
  # Reuse a caller-provided status JSON when available to avoid duplicate expensive probes.
  status_json="${SUPPORT_STATUS_JSON:-}"
  if [[ -z "${status_json}" ]]; then
    status_json=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')
  fi
  backend="$(jq -r '.BackendState // "Unknown"' <<< "${status_json}" 2>/dev/null || echo "Unknown")"
  self_dns_name="$(normalize_dns_value "$(jq -r '.Self.DNSName // empty' <<< "${status_json}" 2>/dev/null || true)")"
  magic_dns_suffix="$(normalize_dns_value "$(jq -r '.CurrentTailnet.MagicDNSSuffix // empty' <<< "${status_json}" 2>/dev/null || true)")"
  candidate_strings="$(jq -r '[.CurrentTailnet.Name,.CurrentTailnet.MagicDNSSuffix,.CurrentTailnet.Tailnet,.Self.DNSName,.Self.HostName,.Self.Tailnet] | map(select(type=="string" and length>0)) | .[]' <<< "${status_json}" 2>/dev/null || true)"

  SUPPORT_ENABLED="${support_enabled}"
  SUPPORT_TARGET_ID=""
  SUPPORT_TARGET_DNS_SUFFIX="${target_dns_suffix}"
  SUPPORT_TARGET_URL="${target_url}"
  SUPPORT_BACKEND="${backend}"
  SUPPORT_TAILNET_MATCH="false"
  SUPPORT_REASON=""

  if [[ -z "${target_dns_suffix}" ]]; then
    SUPPORT_REASON="support_tailnet_dns_suffix vacio"
    return
  fi

  if [[ -n "${target_dns_suffix}" ]]; then
    if dns_matches_suffix "${self_dns_name}" "${target_dns_suffix}"; then
      SUPPORT_TAILNET_MATCH="true"
    elif dns_matches_suffix "${magic_dns_suffix}" "${target_dns_suffix}"; then
      SUPPORT_TAILNET_MATCH="true"
    else
      while IFS= read -r token; do
        token_lc="$(normalize_dns_value "${token}")"
        if dns_matches_suffix "${token_lc}" "${target_dns_suffix}"; then
          SUPPORT_TAILNET_MATCH="true"
          break
        fi
      done <<< "${candidate_strings}"
    fi
  fi

  # Expose DNS match independently from eligibility gates.
  if [[ "${support_enabled}" != "true" ]]; then
    SUPPORT_REASON="support_tunnel_enabled=false"
    return
  fi
  if [[ "${backend}" != "Running" ]]; then
    SUPPORT_REASON="backend_state=${backend}"
    return
  fi
  if [[ "${SUPPORT_TAILNET_MATCH}" != "true" ]]; then
    SUPPORT_REASON="tailnet no coincide con dns suffix de soporte"
  fi
}

write_state() {
  local active pid url eligible now
  active="${1:-false}"
  pid="${2:-}"
  url="${3:-}"
  eligible="${4:-false}"
  now="$(now_utc)"
  read_meta
  jq -nc \
    --arg updated_at "${now}" \
    --arg support_target_id "${SUPPORT_TARGET_ID}" \
    --arg support_target_dns_suffix "${SUPPORT_TARGET_DNS_SUFFIX:-}" \
    --arg support_target_url "${SUPPORT_TARGET_URL}" \
    --arg backend_state "${SUPPORT_BACKEND}" \
    --arg reason "${SUPPORT_REASON}" \
    --arg url "${url}" \
    --arg pid "${pid}" \
    --arg expires_at "${META_EXPIRES_AT}" \
    --argjson expires_epoch "${META_EXPIRES_EPOCH}" \
    --argjson ttl_minutes "${META_TTL_MIN}" \
    --argjson support_enabled "$(json_bool "${SUPPORT_ENABLED}")" \
    --argjson tailnet_match "$(json_bool "${SUPPORT_TAILNET_MATCH}")" \
    --argjson eligible "$(json_bool "${eligible}")" \
    --argjson active "$(json_bool "${active}")" \
    '{
      updated_at: $updated_at,
      support_enabled: $support_enabled,
      support_target_id: $support_target_id,
      support_target_dns_suffix: $support_target_dns_suffix,
      support_target_url: $support_target_url,
      backend_state: $backend_state,
      tailnet_match: $tailnet_match,
      eligible: $eligible,
      active: $active,
      pid: $pid,
      url: $url,
      reason: $reason,
      expires_at: $expires_at,
      expires_epoch: $expires_epoch,
      ttl_minutes: $ttl_minutes
    }' > "${STATE_FILE}"
}

disable_running_tunnel() {
  local reason pid url
  reason="${1:-manual}"
  pid="$(cloudflared_pid)"
  url="$(extract_url)"
  if is_pid_running "${pid}"; then
    kill "${pid}" 2>/dev/null || true
    sleep 0.2
  fi
  rm -f "${PID_FILE}"
  rm -f "${META_FILE}"
  audit_event "disabled" "${reason}" "${url}"
}

status_cmd() {
  local pid active url eligible now_epoch
  build_eligibility
  pid="$(cloudflared_pid)"
  active=false
  url="$(extract_url)"
  if is_pid_running "${pid}"; then
    active=true
  else
    pid=""
    rm -f "${PID_FILE}"
  fi

  # Auto-revoke when TTL expires.
  if [[ "${active}" == "true" ]]; then
    read_meta
    now_epoch="$(date +%s)"
    if [[ "${META_EXPIRES_EPOCH:-0}" -gt 0 ]] && (( now_epoch >= META_EXPIRES_EPOCH )); then
      disable_running_tunnel "ttl_expired"
      active=false
      pid=""
      url=""
      SUPPORT_REASON="ttl_expired"
    fi
  fi

  eligible=false
  if [[ "${SUPPORT_ENABLED}" == "true" && "${SUPPORT_TAILNET_MATCH}" == "true" && "${SUPPORT_BACKEND}" == "Running" ]]; then
    eligible=true
  fi
  write_state "${active}" "${pid}" "${url}" "${eligible}"
  cat "${STATE_FILE}"
}

enable_cmd() {
  local pid loop url ttl_minutes
  build_eligibility
  if [[ "${SUPPORT_ENABLED}" != "true" || "${SUPPORT_TAILNET_MATCH}" != "true" || "${SUPPORT_BACKEND}" != "Running" ]]; then
    write_state false "" "" false
    echo '{"ok":false,"error":"support tunnel no permitido en este estado"}'
    exit 1
  fi

  pid="$(cloudflared_pid)"
  if is_pid_running "${pid}"; then
    status_cmd
    exit 0
  fi

  rm -f "${LOG_FILE}"
  : > "${LOG_FILE}"
  cloudflared tunnel --no-autoupdate --url "${SUPPORT_TARGET_URL}" >> "${LOG_FILE}" 2>&1 &
  pid=$!
  echo "${pid}" > "${PID_FILE}"

  url=""
  for (( loop=0; loop<STARTUP_WAIT_LOOPS; loop++ )); do
    if ! is_pid_running "${pid}"; then
      break
    fi
    url="$(extract_url)"
    if [[ -n "${url}" ]]; then
      break
    fi
    sleep "${STARTUP_WAIT_DELAY}"
  done

  if ! is_pid_running "${pid}"; then
    rm -f "${PID_FILE}"
    SUPPORT_REASON="cloudflared finalizo al arrancar"
    write_state false "" "" false
    echo '{"ok":false,"error":"cloudflared no pudo arrancar"}'
    exit 1
  fi

  ttl_minutes="$(bashio::config "support_tunnel_ttl_minutes" "30")"
  write_meta "${ttl_minutes}"
  audit_event "enabled" "ok" "${url}"
  write_state true "${pid}" "${url}" true
  cat "${STATE_FILE}"
}

disable_cmd() {
  build_eligibility
  disable_running_tunnel "manual_disable"
  write_state false "" "" false
  cat "${STATE_FILE}"
}

audit_cmd() {
  if [[ -f "${AUDIT_FILE}" ]]; then
    tail -n 100 "${AUDIT_FILE}"
  else
    echo ""
  fi
}

case "${1:-status}" in
  status)
    status_cmd
    ;;
  enable)
    enable_cmd
    ;;
  disable)
    disable_cmd
    ;;
  audit)
    audit_cmd
    ;;
  *)
    echo "Usage: support-tunnel [status|enable|disable|audit]" >&2
    exit 2
    ;;
esac
