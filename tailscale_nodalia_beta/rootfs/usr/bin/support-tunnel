#!/command/with-contenv bashio
# shellcheck shell=bash
# ==============================================================================
# Home Assistant App: Tailscale (Nodalia Beta)
# Support access manager (temporary Nodalia support window)
# ==============================================================================
set -euo pipefail

readonly STATE_FILE="/data/support-tunnel.json"
readonly META_FILE="/data/support-tunnel-meta.json"
readonly AUDIT_FILE="/data/support-tunnel-audit.log"

now_utc() {
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

json_bool() {
  if [[ "${1:-false}" == "true" ]]; then
    echo "true"
  else
    echo "false"
  fi
}

normalize_lc() {
  printf '%s' "${1:-}" | tr '[:upper:]' '[:lower:]'
}

normalize_dns_value() {
  local value
  value="${1:-}"
  value="$(normalize_lc "${value}")"
  value="${value#.}"
  value="${value%.}"
  printf '%s' "${value}"
}

dns_matches_suffix() {
  local value suffix
  value="$(normalize_dns_value "${1:-}")"
  suffix="$(normalize_dns_value "${2:-}")"
  if [[ -z "${value}" || -z "${suffix}" ]]; then
    return 1
  fi
  [[ "${value}" == "${suffix}" || "${value}" == *."${suffix}" ]]
}

sanitize_uint() {
  local value
  value="${1:-0}"
  if [[ "${value}" =~ ^[0-9]+$ ]]; then
    printf '%s' "${value}"
  else
    printf '0'
  fi
}

api_call() {
  local method path payload response rc
  method="${1:-GET}"
  path="${2:-}"
  payload="${3:-__NO_PAYLOAD__}"

  set +e
  if [[ "${payload}" == "__NO_PAYLOAD__" ]]; then
    response="$(bashio::api.supervisor "${method}" "${path}" false 2>&1)"
  else
    response="$(bashio::api.supervisor "${method}" "${path}" "${payload}" 2>&1)"
  fi
  rc=$?
  set -e

  API_LAST_RC="${rc}"
  API_LAST_JSON="${response}"
  API_LAST_OUTPUT="$(printf '%s' "${response}" | tail -c 1800)"
  (( rc == 0 ))
}

unwrap_supervisor_data() {
  local input
  input="${1:-null}"
  jq -c 'if type=="object" and (.result?=="ok") and has("data") then .data else . end' <<< "${input}" 2>/dev/null || echo 'null'
}

extract_support_candidate() {
  local users_data needle
  users_data="${1:-null}"
  needle="$(normalize_lc "${2:-}")"
  jq -c --arg needle "${needle}" '
    if type=="object" and (.users? | type=="array") then
      .users
      | map(select(
          ((.username // "" | ascii_downcase)==$needle) or
          ((.name // "" | ascii_downcase)==$needle) or
          ((.id // "" | ascii_downcase)==$needle)
        ))
      | .[0] // empty
    elif type=="array" then
      map(select(
          ((.username // "" | ascii_downcase)==$needle) or
          ((.name // "" | ascii_downcase)==$needle) or
          ((.id // "" | ascii_downcase)==$needle)
        ))
      | .[0] // empty
    else
      empty
    end
  ' <<< "${users_data}" 2>/dev/null || true
}

populate_support_user_from_candidate() {
  local candidate owner active_field active_value login_name
  candidate="${1:-}"
  if [[ -z "${candidate}" ]]; then
    USER_LOOKUP_REASON="support_user_no_encontrado"
    return 1
  fi

  SUPPORT_USER_ID="$(jq -r '.id // empty' <<< "${candidate}" 2>/dev/null || true)"
  if [[ -z "${SUPPORT_USER_ID}" ]]; then
    USER_LOOKUP_REASON="support_user_id_vacio"
    return 1
  fi

  login_name="$(jq -r '.username // ([.credentials[]? | .data.username?] | map(select(type=="string" and length>0)) | .[0]) // .name // empty' <<< "${candidate}" 2>/dev/null || true)"
  if [[ -z "${login_name}" ]]; then
    login_name="${SUPPORT_USER}"
  fi
  SUPPORT_USER_LOGIN_NAME="${login_name}"

  owner="$(jq -r '.is_owner // false' <<< "${candidate}" 2>/dev/null || echo "false")"
  active_field="$(jq -r 'if has("is_active") then "true" else "false" end' <<< "${candidate}" 2>/dev/null || echo "false")"
  active_value="$(jq -r 'if (.is_active // false) then "true" else "false" end' <<< "${candidate}" 2>/dev/null || echo "false")"

  SUPPORT_USER_EXISTS="true"
  if [[ "${owner}" == "true" ]]; then
    SUPPORT_USER_IS_OWNER="true"
  fi
  if [[ "${active_field}" == "true" ]]; then
    SUPPORT_USER_ACTIVE_KNOWN="true"
    SUPPORT_USER_ACTIVE="${active_value}"
  fi
  USER_LOOKUP_REASON=""
  return 0
}

lookup_support_user_core() {
  local users_raw users_data candidate needle

  if ! api_call GET "/core/api/config/users"; then
    USER_LOOKUP_REASON="ha_users_api_error_core"
    return 1
  fi
  users_raw="${API_LAST_JSON}"
  users_data="$(unwrap_supervisor_data "${users_raw}")"
  needle="$(normalize_lc "${SUPPORT_USER}")"
  candidate="$(extract_support_candidate "${users_data}" "${needle}")"
  if ! populate_support_user_from_candidate "${candidate}"; then
    return 1
  fi
  USER_LOOKUP_SOURCE="core_api"
  return 0
}

lookup_support_user_auth() {
  local users_raw users_data candidate needle

  if ! api_call GET "/auth/list"; then
    USER_LOOKUP_REASON="ha_users_api_error_auth"
    return 1
  fi
  users_raw="${API_LAST_JSON}"
  users_data="$(unwrap_supervisor_data "${users_raw}")"
  needle="$(normalize_lc "${SUPPORT_USER}")"
  candidate="$(extract_support_candidate "${users_data}" "${needle}")"
  if ! populate_support_user_from_candidate "${candidate}"; then
    return 1
  fi
  USER_LOOKUP_SOURCE="auth_api"
  return 0
}

lookup_support_user() {
  local core_reason auth_reason

  SUPPORT_USER_EXISTS="false"
  SUPPORT_USER_ACTIVE="false"
  SUPPORT_USER_ACTIVE_KNOWN="false"
  SUPPORT_USER_IS_OWNER="false"
  SUPPORT_USER_ID=""
  SUPPORT_USER_LOGIN_NAME=""
  USER_LOOKUP_REASON=""
  USER_LOOKUP_SOURCE=""

  if [[ -z "${SUPPORT_USER:-}" ]]; then
    USER_LOOKUP_REASON="support_user_vacio"
    return 1
  fi

  if lookup_support_user_core; then
    return 0
  fi
  core_reason="${USER_LOOKUP_REASON:-ha_users_api_error_core}"

  if lookup_support_user_auth; then
    return 0
  fi
  auth_reason="${USER_LOOKUP_REASON:-ha_users_api_error_auth}"

  if [[ "${core_reason}" == "support_user_no_encontrado" && "${auth_reason}" == "support_user_no_encontrado" ]]; then
    USER_LOOKUP_REASON="support_user_no_encontrado"
  elif [[ "${core_reason}" == ha_users_api_error_* && "${auth_reason}" == ha_users_api_error_* ]]; then
    USER_LOOKUP_REASON="ha_users_api_error"
  else
    USER_LOOKUP_REASON="${auth_reason:-${core_reason}}"
  fi
  return 1
}

auth_user_with_password() {
  local username password payload
  username="${1:-}"
  password="${2:-}"
  if [[ -z "${username}" || -z "${password}" ]]; then
    return 1
  fi
  payload="$(jq -nc --arg username "${username}" --arg password "${password}" '{username:$username,password:$password}')"
  if ! api_call POST "/auth" "${payload}"; then
    return 1
  fi
  return 0
}

reset_user_password() {
  local username password payload
  username="${1:-}"
  password="${2:-}"
  if [[ -z "${username}" || -z "${password}" ]]; then
    return 1
  fi
  payload="$(jq -nc --arg username "${username}" --arg password "${password}" '{username:$username,password:$password}')"
  if ! api_call POST "/auth/reset" "${payload}"; then
    return 1
  fi
  return 0
}

set_support_user_active_via_core() {
  local desired payload
  desired="${1:-false}"
  if [[ -z "${SUPPORT_USER_ID:-}" ]]; then
    USER_OP_REASON="support_user_id_vacio"
    return 1
  fi
  payload="$(jq -nc --argjson is_active "$(json_bool "${desired}")" '{is_active:$is_active}')"
  if ! api_call PATCH "/core/api/config/users/${SUPPORT_USER_ID}" "${payload}"; then
    if ! api_call POST "/core/api/auth/users/${SUPPORT_USER_ID}" "${payload}"; then
      USER_OP_REASON="core_user_patch_failed"
      return 1
    fi
  fi
  SUPPORT_USER_ACTIVE_KNOWN="true"
  SUPPORT_USER_ACTIVE="${desired}"
  USER_OP_REASON="core_user_patch_ok"
  return 0
}

set_support_user_active() {
  local desired random_password core_reason
  desired="${1:-false}"
  USER_OP_REASON=""

  if [[ "${SUPPORT_USER_EXISTS:-false}" != "true" ]]; then
    if ! lookup_support_user; then
      USER_OP_REASON="${USER_LOOKUP_REASON:-support_user_lookup_failed}"
      return 1
    fi
  fi

  if [[ "${SUPPORT_USER_IS_OWNER}" == "true" ]]; then
    USER_OP_REASON="support_user_es_owner_no_permitido"
    return 1
  fi

  if set_support_user_active_via_core "${desired}"; then
    return 0
  fi
  core_reason="${USER_OP_REASON:-core_user_patch_failed}"

  if [[ "${desired}" == "true" ]]; then
    if [[ -z "${SUPPORT_USER_PASSWORD:-}" ]]; then
      USER_OP_REASON="${core_reason}"
      return 1
    fi
    if auth_user_with_password "${SUPPORT_USER_LOGIN_NAME}" "${SUPPORT_USER_PASSWORD}"; then
      SUPPORT_USER_ACTIVE="true"
      USER_OP_REASON="already_true"
      return 0
    fi
    if ! reset_user_password "${SUPPORT_USER_LOGIN_NAME}" "${SUPPORT_USER_PASSWORD}"; then
      USER_OP_REASON="reset_password_failed"
      return 1
    fi
    if auth_user_with_password "${SUPPORT_USER_LOGIN_NAME}" "${SUPPORT_USER_PASSWORD}"; then
      SUPPORT_USER_ACTIVE="true"
      USER_OP_REASON="password_set_enable"
      return 0
    fi
    USER_OP_REASON="enable_verify_failed"
    return 1
  fi

  random_password="$(head -c 32 /dev/urandom 2>/dev/null | base64 2>/dev/null | tr -dc 'A-Za-z0-9' | head -c 32)"
  if [[ -z "${random_password}" ]]; then
    random_password="nodalia$(date +%s)$(od -An -N4 -tx4 /dev/urandom 2>/dev/null | tr -d ' \n' || true)"
  fi
  if ! reset_user_password "${SUPPORT_USER_LOGIN_NAME}" "${random_password}"; then
    USER_OP_REASON="reset_password_failed"
    return 1
  fi
  SUPPORT_USER_ACTIVE_KNOWN="true"
  SUPPORT_USER_ACTIVE="false"
  USER_OP_REASON="password_rotated_disable"
  return 0

}

audit_event() {
  local action reason details now
  action="${1:-unknown}"
  reason="${2:-}"
  details="${3:-}"
  now="$(now_utc)"
  jq -nc \
    --arg ts "${now}" \
    --arg action "${action}" \
    --arg reason "${reason}" \
    --arg details "${details}" \
    --arg actor "${SUPPORT_ACTOR:-ui}" \
    --arg target_id "${SUPPORT_TARGET_ID:-}" \
    --arg target_dns_suffix "${SUPPORT_TARGET_DNS_SUFFIX:-}" \
    --arg support_user "${SUPPORT_USER:-}" \
    --arg support_user_id "${SUPPORT_USER_ID:-}" \
    '{ts:$ts,action:$action,reason:$reason,details:$details,actor:$actor,target_id:$target_id,target_dns_suffix:$target_dns_suffix,support_user:$support_user,support_user_id:$support_user_id}' \
    >> "${AUDIT_FILE}"
}

read_meta() {
  local raw_epoch raw_ttl
  META_EXPIRES_EPOCH=0
  META_EXPIRES_AT=""
  META_TTL_MIN=0
  META_SUPPORT_USER=""
  if [[ -f "${META_FILE}" ]]; then
    raw_epoch="$(jq -r '.expires_epoch // 0' "${META_FILE}" 2>/dev/null || echo "0")"
    META_EXPIRES_EPOCH="$(sanitize_uint "${raw_epoch}")"
    META_EXPIRES_AT="$(jq -r '.expires_at // empty' "${META_FILE}" 2>/dev/null || true)"
    raw_ttl="$(jq -r '.ttl_minutes // 0' "${META_FILE}" 2>/dev/null || echo "0")"
    META_TTL_MIN="$(sanitize_uint "${raw_ttl}")"
    META_SUPPORT_USER="$(jq -r '.support_user // empty' "${META_FILE}" 2>/dev/null || true)"
  fi
}

prepare_meta() {
  local ttl now_epoch expires_epoch expires_at
  ttl="${1:-30}"
  if ! [[ "${ttl}" =~ ^[0-9]+$ ]]; then
    ttl="30"
  fi
  now_epoch="$(date +%s)"
  expires_epoch=$((now_epoch + ttl * 60))
  expires_at="$(date -u -r "${expires_epoch}" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || true)"
  if [[ -z "${expires_at}" ]]; then
    expires_at="$(date -u -d "@${expires_epoch}" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || true)"
  fi
  META_NEW_CREATED_AT="$(now_utc)"
  META_NEW_EXPIRES_EPOCH="${expires_epoch}"
  META_NEW_EXPIRES_AT="${expires_at}"
  META_NEW_TTL_MIN="${ttl}"
}

write_meta() {
  jq -nc \
    --arg created_at "${META_NEW_CREATED_AT}" \
    --arg expires_at "${META_NEW_EXPIRES_AT}" \
    --arg support_user "${SUPPORT_USER}" \
    --argjson expires_epoch "${META_NEW_EXPIRES_EPOCH}" \
    --argjson ttl_minutes "${META_NEW_TTL_MIN}" \
    '{created_at:$created_at,expires_at:$expires_at,expires_epoch:$expires_epoch,ttl_minutes:$ttl_minutes,support_user:$support_user}' > "${META_FILE}"
}

clear_meta() {
  rm -f "${META_FILE}"
}

build_eligibility() {
  local status_json support_enabled target_dns_suffix backend candidate_strings
  local self_dns_name magic_dns_suffix token_lc
  support_enabled=false
  if bashio::config.has_value "support_tunnel_enabled" && bashio::config.true "support_tunnel_enabled"; then
    support_enabled=true
  fi

  target_dns_suffix="$(normalize_dns_value "$(bashio::config "support_tailnet_dns_suffix" "tail37b857.ts.net")")"
  status_json="${SUPPORT_STATUS_JSON:-}"
  if [[ -z "${status_json}" ]]; then
    status_json=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')
  fi
  backend="$(jq -r '.BackendState // "Unknown"' <<< "${status_json}" 2>/dev/null || echo "Unknown")"
  self_dns_name="$(normalize_dns_value "$(jq -r '.Self.DNSName // empty' <<< "${status_json}" 2>/dev/null || true)")"
  magic_dns_suffix="$(normalize_dns_value "$(jq -r '.CurrentTailnet.MagicDNSSuffix // empty' <<< "${status_json}" 2>/dev/null || true)")"
  candidate_strings="$(jq -r '[.CurrentTailnet.Name,.CurrentTailnet.MagicDNSSuffix,.CurrentTailnet.Tailnet,.Self.DNSName,.Self.HostName,.Self.Tailnet] | map(select(type=="string" and length>0)) | .[]' <<< "${status_json}" 2>/dev/null || true)"

  SUPPORT_ENABLED="${support_enabled}"
  SUPPORT_TARGET_ID=""
  SUPPORT_TARGET_DNS_SUFFIX="${target_dns_suffix}"
  SUPPORT_BACKEND="${backend}"
  SUPPORT_REASON=""
  SUPPORT_TAILNET_MATCH="false"
  SUPPORT_USER="$(bashio::config "support_user" "Nodalia")"

  SUPPORT_USER_EXISTS="false"
  SUPPORT_USER_ACTIVE="false"
  SUPPORT_USER_ACTIVE_KNOWN="false"
  SUPPORT_USER_IS_OWNER="false"
  SUPPORT_USER_ID=""
  SUPPORT_USER_LOGIN_NAME=""

  if [[ -z "${target_dns_suffix}" ]]; then
    SUPPORT_REASON="support_tailnet_dns_suffix_vacio"
    return
  fi

  if dns_matches_suffix "${self_dns_name}" "${target_dns_suffix}"; then
    SUPPORT_TAILNET_MATCH="true"
  elif dns_matches_suffix "${magic_dns_suffix}" "${target_dns_suffix}"; then
    SUPPORT_TAILNET_MATCH="true"
  else
    while IFS= read -r token; do
      token_lc="$(normalize_dns_value "${token}")"
      if dns_matches_suffix "${token_lc}" "${target_dns_suffix}"; then
        SUPPORT_TAILNET_MATCH="true"
        break
      fi
    done <<< "${candidate_strings}"
  fi

  if [[ "${support_enabled}" != "true" ]]; then
    SUPPORT_REASON="support_tunnel_enabled=false"
    return
  fi
  if [[ "${backend}" != "Running" ]]; then
    SUPPORT_REASON="backend_state=${backend}"
    return
  fi
  if [[ "${SUPPORT_TAILNET_MATCH}" != "true" ]]; then
    SUPPORT_REASON="tailnet_no_coincide_dns_soporte"
    return
  fi

  if ! lookup_support_user; then
    SUPPORT_REASON="${USER_LOOKUP_REASON:-support_user_lookup_failed}"
    return
  fi

  if [[ "${SUPPORT_USER_IS_OWNER}" == "true" ]]; then
    SUPPORT_REASON="support_user_es_owner_no_permitido"
    return
  fi
}

write_state() {
  local active eligible now
  active="${1:-false}"
  eligible="${2:-false}"
  now="$(now_utc)"
  read_meta

  jq -nc \
    --arg updated_at "${now}" \
    --arg support_target_id "${SUPPORT_TARGET_ID}" \
    --arg support_target_dns_suffix "${SUPPORT_TARGET_DNS_SUFFIX}" \
    --arg backend_state "${SUPPORT_BACKEND}" \
    --arg reason "${SUPPORT_REASON}" \
    --arg expires_at "${META_EXPIRES_AT}" \
    --arg support_user "${SUPPORT_USER}" \
    --arg support_user_id "${SUPPORT_USER_ID}" \
    --argjson expires_epoch "${META_EXPIRES_EPOCH}" \
    --argjson ttl_minutes "${META_TTL_MIN}" \
    --argjson support_enabled "$(json_bool "${SUPPORT_ENABLED}")" \
    --argjson tailnet_match "$(json_bool "${SUPPORT_TAILNET_MATCH}")" \
    --argjson eligible "$(json_bool "${eligible}")" \
    --argjson active "$(json_bool "${active}")" \
    --argjson support_user_exists "$(json_bool "${SUPPORT_USER_EXISTS}")" \
    --argjson support_user_active "$(json_bool "${SUPPORT_USER_ACTIVE}")" \
    --argjson support_user_active_known "$(json_bool "${SUPPORT_USER_ACTIVE_KNOWN}")" \
    --argjson support_user_is_owner "$(json_bool "${SUPPORT_USER_IS_OWNER}")" \
    '{
      updated_at:$updated_at,
      support_enabled:$support_enabled,
      support_target_id:$support_target_id,
      support_target_dns_suffix:$support_target_dns_suffix,
      backend_state:$backend_state,
      tailnet_match:$tailnet_match,
      eligible:$eligible,
      active:$active,
      support_user:$support_user,
      support_user_id:$support_user_id,
      support_user_exists:$support_user_exists,
      support_user_active:$support_user_active,
      support_user_active_known:$support_user_active_known,
      support_user_is_owner:$support_user_is_owner,
      pid:"",
      url:"",
      reason:$reason,
      expires_at:$expires_at,
      expires_epoch:$expires_epoch,
      ttl_minutes:$ttl_minutes
    }' > "${STATE_FILE}"
}

disable_running_access() {
  local reason details rc
  reason="${1:-manual_disable}"
  details=""
  rc=0

  if ! set_support_user_active false; then
    details="user_disable_error:${USER_OP_REASON}"
    rc=1
  else
    details="user_disable_ok:${USER_OP_REASON}"
  fi

  clear_meta
  audit_event "disabled" "${reason}" "${details}"
  return "${rc}"
}

status_cmd() {
  local active eligible now_epoch
  build_eligibility
  read_meta

  active=false
  now_epoch="$(date +%s)"
  if [[ "${META_EXPIRES_EPOCH:-0}" -gt 0 ]]; then
    if (( now_epoch >= META_EXPIRES_EPOCH )); then
      disable_running_access "ttl_expired" >/dev/null 2>&1 || true
      SUPPORT_REASON="ttl_expired"
      active=false
    elif [[ "${SUPPORT_USER_EXISTS}" == "true" ]]; then
      if [[ "${SUPPORT_USER_ACTIVE_KNOWN}" != "true" ]]; then
        active=true
      elif [[ "${SUPPORT_USER_ACTIVE}" == "true" ]]; then
        active=true
      else
        clear_meta
        SUPPORT_REASON="support_user_inactivo_sin_sesion"
        active=false
      fi
    else
      # If support user lookup couldn't run in this cycle (e.g. backend state gate),
      # preserve the active window until we can verify user state again.
      active=true
    fi
  fi

  eligible=false
  if [[ "${SUPPORT_ENABLED}" == "true" && "${SUPPORT_TAILNET_MATCH}" == "true" && "${SUPPORT_BACKEND}" == "Running" ]] && \
    [[ "${SUPPORT_USER_EXISTS}" == "true" && "${SUPPORT_USER_IS_OWNER}" != "true" ]]; then
    eligible=true
  fi

  write_state "${active}" "${eligible}"
  cat "${STATE_FILE}"
}

enable_cmd() {
  local ttl_minutes details
  build_eligibility

  if [[ "${SUPPORT_ENABLED}" != "true" || "${SUPPORT_TAILNET_MATCH}" != "true" || "${SUPPORT_BACKEND}" != "Running" ]] || \
    [[ "${SUPPORT_USER_EXISTS}" != "true" || "${SUPPORT_USER_IS_OWNER}" == "true" ]]; then
    write_state false false
    echo '{"ok":false,"error":"support access no permitido en este estado"}'
    exit 1
  fi

  read_meta
  if [[ "${META_EXPIRES_EPOCH:-0}" -gt 0 ]]; then
    if [[ "${SUPPORT_USER_ACTIVE}" == "true" ]] && (( $(date +%s) < META_EXPIRES_EPOCH )); then
      write_state true true
      cat "${STATE_FILE}"
      exit 0
    fi
  fi

  if ! set_support_user_active true; then
    SUPPORT_REASON="${USER_OP_REASON}"
    write_state false true
    echo '{"ok":false,"error":"no se pudo habilitar support_user"}'
    exit 1
  fi

  ttl_minutes="$(bashio::config "support_tunnel_ttl_minutes" "30")"
  prepare_meta "${ttl_minutes}"
  write_meta

  details="user_enable_ok:${USER_OP_REASON}"
  audit_event "enabled" "ok" "${details}"
  write_state true true
  cat "${STATE_FILE}"
}

disable_cmd() {
  build_eligibility

  if ! disable_running_access "manual_disable"; then
    SUPPORT_REASON="${USER_OP_REASON:-disable_failed}"
    write_state false false
    echo '{"ok":false,"error":"no se pudo revocar support_user"}'
    exit 1
  fi

  SUPPORT_REASON="manual_disable"
  write_state false false
  cat "${STATE_FILE}"
}

audit_cmd() {
  if [[ -f "${AUDIT_FILE}" ]]; then
    tail -n 100 "${AUDIT_FILE}"
  else
    echo ""
  fi
}

fallback_status_json() {
  local reason cfg_dns cfg_user cfg_enabled
  reason="${1:-support_status_failed}"
  cfg_dns="$(bashio::config "support_tailnet_dns_suffix" 2>/dev/null || true)"
  if [[ -z "${cfg_dns}" ]]; then
    cfg_dns="tail37b857.ts.net"
  fi
  cfg_user="$(bashio::config "support_user" 2>/dev/null || true)"
  if [[ -z "${cfg_user}" ]]; then
    cfg_user="Nodalia"
  fi
  cfg_enabled=false
  if bashio::config.has_value "support_tunnel_enabled" && bashio::config.true "support_tunnel_enabled"; then
    cfg_enabled=true
  fi
  jq -nc \
    --arg updated_at "$(now_utc)" \
    --arg support_target_dns_suffix "${cfg_dns}" \
    --arg support_user "${cfg_user}" \
    --arg reason "${reason}" \
    --argjson support_enabled "$(json_bool "${cfg_enabled}")" \
    '{
      updated_at:$updated_at,
      support_enabled:$support_enabled,
      support_target_id:"",
      support_target_dns_suffix:$support_target_dns_suffix,
      backend_state:"Unknown",
      tailnet_match:false,
      eligible:false,
      active:false,
      support_user:$support_user,
      support_user_id:"",
      support_user_exists:false,
      support_user_active:false,
      support_user_active_known:false,
      support_user_is_owner:false,
      pid:"",
      url:"",
      reason:$reason,
      expires_at:"",
      expires_epoch:0,
      ttl_minutes:0
    }'
}

case "${1:-status}" in
  status)
    if ! status_cmd; then
      fallback_status_json "support_status_failed"
      exit 0
    fi
    ;;
  enable)
    enable_cmd
    ;;
  disable)
    disable_cmd
    ;;
  audit)
    audit_cmd
    ;;
  *)
    echo "Usage: support-tunnel [status|enable|disable|audit]" >&2
    exit 2
    ;;
esac
