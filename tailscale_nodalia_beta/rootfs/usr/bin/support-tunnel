#!/command/with-contenv bashio
# shellcheck shell=bash
# ==============================================================================
# Home Assistant App: Tailscale (Nodalia Beta)
# Support access manager (temporary Nodalia support window)
# ==============================================================================
set -euo pipefail

readonly STATE_FILE="/data/support-tunnel.json"
readonly META_FILE="/data/support-tunnel-meta.json"
readonly AUDIT_FILE="/data/support-tunnel-audit.log"

now_utc() {
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

json_bool() {
  if [[ "${1:-false}" == "true" ]]; then
    echo "true"
  else
    echo "false"
  fi
}

normalize_lc() {
  printf '%s' "${1:-}" | tr '[:upper:]' '[:lower:]'
}

normalize_dns_value() {
  local value
  value="${1:-}"
  value="$(normalize_lc "${value}")"
  value="${value#.}"
  value="${value%.}"
  printf '%s' "${value}"
}

dns_matches_suffix() {
  local value suffix
  value="$(normalize_dns_value "${1:-}")"
  suffix="$(normalize_dns_value "${2:-}")"
  if [[ -z "${value}" || -z "${suffix}" ]]; then
    return 1
  fi
  [[ "${value}" == "${suffix}" || "${value}" == *."${suffix}" ]]
}

sanitize_uint() {
  local value
  value="${1:-0}"
  if [[ "${value}" =~ ^[0-9]+$ ]]; then
    printf '%s' "${value}"
  else
    printf '0'
  fi
}

trim_spaces() {
  local value
  value="${1:-}"
  value="${value#"${value%%[![:space:]]*}"}"
  value="${value%"${value##*[![:space:]]}"}"
  printf '%s' "${value}"
}

read_json_file_or_empty() {
  local path
  path="${1:-}"
  if [[ -n "${path}" && -f "${path}" ]]; then
    jq -c '.' "${path}" 2>/dev/null || echo '{}'
  else
    echo '{}'
  fi
}

resolve_support_enable_password() {
  local configured_password
  if [[ -n "${SUPPORT_USER_PASSWORD:-}" ]]; then
    printf '%s' "${SUPPORT_USER_PASSWORD}"
    return 0
  fi
  configured_password="$(bashio::config "support_user_password" "" 2>/dev/null || true)"
  if [[ -n "${configured_password}" ]]; then
    printf '%s' "${configured_password}"
    return 0
  fi
  if [[ -n "${SUPPORT_USER_LOGIN_NAME:-}" ]]; then
    printf '%s' "${SUPPORT_USER_LOGIN_NAME}"
    return 0
  fi
  printf '%s' "${SUPPORT_USER:-}"
}

api_call() {
  local method path payload response rc err_file stderr_output
  method="${1:-GET}"
  path="${2:-}"
  payload="${3:-__NO_PAYLOAD__}"
  stderr_output=""

  err_file="$(mktemp /tmp/support-api-stderr.XXXXXX 2>/dev/null || true)"
  if [[ -n "${err_file}" ]]; then
    set +e
    if [[ "${payload}" == "__NO_PAYLOAD__" ]]; then
      response="$(bashio::api.supervisor "${method}" "${path}" false 2>"${err_file}")"
    else
      response="$(bashio::api.supervisor "${method}" "${path}" "${payload}" 2>"${err_file}")"
    fi
    rc=$?
    set -e
    stderr_output="$(cat "${err_file}" 2>/dev/null || true)"
    rm -f "${err_file}" || true
  else
    set +e
    if [[ "${payload}" == "__NO_PAYLOAD__" ]]; then
      response="$(bashio::api.supervisor "${method}" "${path}" false 2>&1)"
    else
      response="$(bashio::api.supervisor "${method}" "${path}" "${payload}" 2>&1)"
    fi
    rc=$?
    set -e
  fi

  API_LAST_RC="${rc}"
  API_LAST_JSON="${response}"
  API_LAST_STDERR="${stderr_output}"
  API_LAST_OUTPUT="$(printf '%s\n%s\n' "${stderr_output}" "${response}" | tail -n 80)"
  (( rc == 0 ))
}

unwrap_supervisor_data() {
  local input
  input="${1:-null}"
  jq -c 'if type=="object" and (.result?=="ok") and has("data") then .data else . end' <<< "${input}" 2>/dev/null || echo 'null'
}

extract_support_candidate() {
  local users_data needle
  users_data="${1:-null}"
  needle="$(normalize_lc "${2:-}")"
  jq -c --arg needle "${needle}" '
    def norm: (tostring | ascii_downcase);
    def matches:
      (
        (.username // .user.username // "" | norm) == $needle
      ) or (
        (.name // .user.name // "" | norm) == $needle
      ) or (
        (.id // .user_id // .user.id // .user.user_id // .uuid // .user.uuid // .uid // .user.uid // "" | norm) == $needle
      );
    if type=="object" and (.users? | type=="array") then
      .users
      | map(select(matches))
      | .[0] // empty
    elif type=="array" then
      map(select(matches))
      | .[0] // empty
    else
      empty
    end
  ' <<< "${users_data}" 2>/dev/null || true
}

populate_support_user_from_candidate() {
  local candidate owner active_field active_value login_name
  candidate="${1:-}"
  if [[ -z "${candidate}" ]]; then
    USER_LOOKUP_REASON="support_user_no_encontrado"
    return 1
  fi

  SUPPORT_USER_ID="$(jq -r '.id // .user_id // .user.id // .user.user_id // .uuid // .user.uuid // .uid // .user.uid // empty' <<< "${candidate}" 2>/dev/null || true)"

  login_name="$(jq -r '.username // .user.username // ([.credentials[]? | .data.username?] | map(select(type=="string" and length>0)) | .[0]) // .name // .user.name // empty' <<< "${candidate}" 2>/dev/null || true)"
  if [[ -z "${login_name}" ]]; then
    login_name="${SUPPORT_USER}"
  fi
  SUPPORT_USER_LOGIN_NAME="${login_name}"

  owner="$(jq -r '.is_owner // .user.is_owner // false' <<< "${candidate}" 2>/dev/null || echo "false")"
  active_field="$(jq -r 'if has("is_active") or ((.user? | type=="object") and (.user | has("is_active"))) then "true" else "false" end' <<< "${candidate}" 2>/dev/null || echo "false")"
  active_value="$(jq -r 'if (.is_active // .user.is_active // false) then "true" else "false" end' <<< "${candidate}" 2>/dev/null || echo "false")"

  SUPPORT_USER_EXISTS="true"
  if [[ "${owner}" == "true" ]]; then
    SUPPORT_USER_IS_OWNER="true"
  fi
  if [[ "${active_field}" == "true" ]]; then
    SUPPORT_USER_ACTIVE_KNOWN="true"
    SUPPORT_USER_ACTIVE="${active_value}"
  fi
  if [[ -z "${SUPPORT_USER_ID}" ]]; then
    USER_LOOKUP_REASON="support_user_id_vacio"
    return 2
  fi
  USER_LOOKUP_REASON=""
  return 0
}

lookup_support_user_core() {
  local users_raw users_data candidate needle populate_rc path any_ok last_reason

  any_ok=false
  last_reason=""
  for path in "/core/api/config/users" "/core/api/users"; do
    if ! api_call GET "${path}"; then
      continue
    fi
    any_ok=true
    users_raw="${API_LAST_JSON}"
    users_data="$(unwrap_supervisor_data "${users_raw}")"
    needle="$(normalize_lc "${SUPPORT_USER}")"
    candidate="$(extract_support_candidate "${users_data}" "${needle}")"
    set +e
    populate_support_user_from_candidate "${candidate}"
    populate_rc=$?
    set -e
    if (( populate_rc == 0 )); then
      USER_LOOKUP_SOURCE="core_api"
      CORE_USERS_ENDPOINT_USED="${path}"
      return 0
    fi
    if (( populate_rc == 2 )); then
      USER_LOOKUP_SOURCE="core_api_no_id"
      CORE_USERS_ENDPOINT_USED="${path}"
      return 2
    fi
    last_reason="${USER_LOOKUP_REASON:-support_user_no_encontrado}"
  done

  if [[ "${any_ok}" == "true" ]]; then
    USER_LOOKUP_REASON="${last_reason:-support_user_no_encontrado}"
  else
    USER_LOOKUP_REASON="ha_users_api_error_core"
  fi
  return 1
}

lookup_support_user_auth() {
  local users_raw users_data candidate needle populate_rc path any_ok last_reason

  any_ok=false
  last_reason=""
  for path in "/auth/list" "/auth/list?raw=true" "/auth/users" "/auth/users/list"; do
    if ! api_call GET "${path}"; then
      continue
    fi
    any_ok=true
    users_raw="${API_LAST_JSON}"
    users_data="$(unwrap_supervisor_data "${users_raw}")"
    needle="$(normalize_lc "${SUPPORT_USER}")"
    candidate="$(extract_support_candidate "${users_data}" "${needle}")"
    set +e
    populate_support_user_from_candidate "${candidate}"
    populate_rc=$?
    set -e
    if (( populate_rc == 0 )); then
      USER_LOOKUP_SOURCE="auth_api"
      AUTH_USERS_ENDPOINT_USED="${path}"
      return 0
    fi
    if (( populate_rc == 2 )); then
      USER_LOOKUP_SOURCE="auth_api_no_id"
      AUTH_USERS_ENDPOINT_USED="${path}"
      return 2
    fi
    last_reason="${USER_LOOKUP_REASON:-support_user_no_encontrado}"
  done

  if [[ "${any_ok}" == "true" ]]; then
    USER_LOOKUP_REASON="${last_reason:-support_user_no_encontrado}"
  else
    USER_LOOKUP_REASON="ha_users_api_error_auth"
  fi
  return 1
}

lookup_support_user() {
  local core_reason auth_reason core_rc auth_rc

  SUPPORT_USER_EXISTS="false"
  SUPPORT_USER_ACTIVE="false"
  SUPPORT_USER_ACTIVE_KNOWN="false"
  SUPPORT_USER_IS_OWNER="false"
  SUPPORT_USER_ID=""
  SUPPORT_USER_LOGIN_NAME=""
  CORE_USERS_ENDPOINT_USED=""
  AUTH_USERS_ENDPOINT_USED=""
  USER_LOOKUP_REASON=""
  USER_LOOKUP_SOURCE=""

  if [[ -z "${SUPPORT_USER:-}" ]]; then
    USER_LOOKUP_REASON="support_user_vacio"
    return 1
  fi

  set +e
  lookup_support_user_core
  core_rc=$?
  set -e
  if (( core_rc == 0 )); then
    return 0
  fi
  core_reason="${USER_LOOKUP_REASON:-ha_users_api_error_core}"

  set +e
  lookup_support_user_auth
  auth_rc=$?
  set -e
  if (( auth_rc == 0 )); then
    return 0
  fi
  auth_reason="${USER_LOOKUP_REASON:-ha_users_api_error_auth}"

  # Some Supervisor/Auth responses expose username/name but hide the user ID.
  # We continue with degraded mode and let the activation path try login-name based patch.
  if (( core_rc == 2 || auth_rc == 2 )); then
    USER_LOOKUP_REASON="support_user_id_vacio"
    return 0
  fi

  if [[ "${core_reason}" == "support_user_no_encontrado" && "${auth_reason}" == "support_user_no_encontrado" ]]; then
    USER_LOOKUP_REASON="support_user_no_encontrado"
  elif [[ "${core_reason}" == ha_users_api_error_* && "${auth_reason}" == ha_users_api_error_* ]]; then
    USER_LOOKUP_REASON="ha_users_api_error"
  else
    USER_LOOKUP_REASON="${auth_reason:-${core_reason}}"
  fi
  return 1
}

auth_user_with_password() {
  local username password payload
  username="${1:-}"
  password="${2:-}"
  if [[ -z "${username}" || -z "${password}" ]]; then
    return 1
  fi
  payload="$(jq -nc --arg username "${username}" --arg password "${password}" '{username:$username,password:$password}')"
  if ! api_call POST "/auth" "${payload}"; then
    return 1
  fi
  return 0
}

reset_user_password() {
  local username password payload
  username="${1:-}"
  password="${2:-}"
  if [[ -z "${username}" || -z "${password}" ]]; then
    return 1
  fi
  payload="$(jq -nc --arg username "${username}" --arg password "${password}" '{username:$username,password:$password}')"
  if ! api_call POST "/auth/reset" "${payload}"; then
    return 1
  fi
  return 0
}

set_support_user_active_via_core() {
  local desired payload target path method
  desired="${1:-false}"
  payload="$(jq -nc --argjson is_active "$(json_bool "${desired}")" '{is_active:$is_active}')"

  target=""
  if [[ -n "${SUPPORT_USER_ID:-}" ]]; then
    target="$(jq -rn --arg v "${SUPPORT_USER_ID}" '$v|@uri' 2>/dev/null || true)"
  elif [[ -n "${SUPPORT_USER_LOGIN_NAME:-}" ]]; then
    target="$(jq -rn --arg v "${SUPPORT_USER_LOGIN_NAME}" '$v|@uri' 2>/dev/null || true)"
  fi
  if [[ -z "${target}" ]]; then
    USER_OP_REASON="support_user_id_vacio"
    return 1
  fi

  for path in \
    "${CORE_USERS_ENDPOINT_USED:-/core/api/config/users}/${target}" \
    "/core/api/config/users/${target}" \
    "/core/api/users/${target}" \
    "/core/api/auth/users/${target}"
  do
    for method in PATCH POST; do
      if api_call "${method}" "${path}" "${payload}"; then
        SUPPORT_USER_ACTIVE_KNOWN="true"
        SUPPORT_USER_ACTIVE="${desired}"
        if [[ -z "${SUPPORT_USER_ID:-}" ]]; then
          USER_OP_REASON="core_user_patch_by_login_ok"
        else
          USER_OP_REASON="core_user_patch_ok"
        fi
        USER_OP_PATH="${method}:${path}"
        return 0
      fi
    done
  done

  if [[ -z "${SUPPORT_USER_ID:-}" ]]; then
    USER_OP_REASON="core_user_patch_failed_no_id"
  else
    USER_OP_REASON="core_user_patch_failed"
  fi
  USER_OP_PATH=""
  return 1
}

verify_support_user_state() {
  local expected lookup_rc
  expected="${1:-false}"
  set +e
  lookup_support_user
  lookup_rc=$?
  set -e
  if (( lookup_rc != 0 )); then
    USER_OP_REASON="support_user_verify_failed"
    return 1
  fi
  if [[ "${SUPPORT_USER_ACTIVE_KNOWN}" != "true" ]]; then
    USER_OP_REASON="support_user_active_unknown_after_verify"
    return 1
  fi
  if [[ "${SUPPORT_USER_ACTIVE}" != "${expected}" ]]; then
    if [[ "${expected}" == "false" ]]; then
      USER_OP_REASON="password_rotated_but_user_still_active"
    else
      USER_OP_REASON="support_user_still_inactive_after_enable"
    fi
    return 1
  fi
  return 0
}

set_support_user_active_via_service() {
  local desired action service_cfg service_domain service_name path payload
  local support_dns
  desired="${1:-false}"

  if [[ "${desired}" == "true" ]]; then
    action="enable"
    service_cfg="$(trim_spaces "$(bashio::config "support_enable_service" "" 2>/dev/null || true)")"
  else
    action="disable"
    service_cfg="$(trim_spaces "$(bashio::config "support_disable_service" "" 2>/dev/null || true)")"
  fi

  if [[ -z "${service_cfg}" ]]; then
    USER_OP_REASON="support_${action}_service_not_configured"
    return 2
  fi
  if ! [[ "${service_cfg}" =~ ^[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+$ ]]; then
    USER_OP_REASON="support_${action}_service_invalid"
    return 1
  fi

  service_domain="${service_cfg%%.*}"
  service_name="${service_cfg#*.}"
  path="/core/api/services/${service_domain}/${service_name}"
  support_dns="${SUPPORT_TARGET_DNS_SUFFIX:-}"
  payload="$(jq -nc \
    --arg action "${action}" \
    --arg support_user "${SUPPORT_USER:-}" \
    --arg support_user_login_name "${SUPPORT_USER_LOGIN_NAME:-}" \
    --arg support_user_id "${SUPPORT_USER_ID:-}" \
    --arg support_target_dns_suffix "${support_dns}" \
    --argjson enabled "$(json_bool "${desired}")" \
    '{
      action:$action,
      enabled:$enabled,
      support_user:$support_user,
      support_user_login_name:$support_user_login_name,
      support_user_id:$support_user_id,
      support_target_dns_suffix:$support_target_dns_suffix
    }')"

  USER_OP_PATH="POST:${path}"
  if ! api_call POST "${path}" "${payload}"; then
    USER_OP_REASON="support_${action}_service_api_failed"
    return 1
  fi
  if ! verify_support_user_state "${desired}"; then
    USER_OP_REASON="support_${action}_service_no_effect:${USER_OP_REASON}"
    return 1
  fi
  USER_OP_REASON="support_${action}_service_ok"
  return 0
}

set_support_user_active_via_auth() {
  local desired target method path payload
  local payload_base payload_username payload_name
  desired="${1:-false}"

  target=""
  if [[ -n "${SUPPORT_USER_LOGIN_NAME:-}" ]]; then
    target="$(jq -rn --arg v "${SUPPORT_USER_LOGIN_NAME}" '$v|@uri' 2>/dev/null || true)"
  fi
  if [[ -z "${target}" ]]; then
    USER_OP_REASON="support_user_login_name_vacio"
    return 1
  fi

  payload_base="$(jq -nc --argjson is_active "$(json_bool "${desired}")" '{is_active:$is_active}')"
  payload_username="$(jq -nc --arg username "${SUPPORT_USER_LOGIN_NAME}" --argjson is_active "$(json_bool "${desired}")" '{username:$username,is_active:$is_active}')"
  payload_name="$(jq -nc --arg name "${SUPPORT_USER_LOGIN_NAME}" --argjson is_active "$(json_bool "${desired}")" '{name:$name,is_active:$is_active}')"

  for path in \
    "/auth/users/${target}" \
    "/auth/user/${target}" \
    "/auth/${target}" \
    "/auth/update"
  do
    for method in PATCH POST PUT; do
      for payload in "${payload_base}" "${payload_username}" "${payload_name}"; do
        if api_call "${method}" "${path}" "${payload}"; then
          USER_OP_PATH="${method}:${path}"
          if verify_support_user_state "${desired}"; then
            USER_OP_REASON="auth_user_patch_ok"
            return 0
          fi
        fi
      done
    done
  done

  USER_OP_REASON="auth_user_patch_failed"
  return 1
}

set_support_user_active() {
  local desired random_password core_reason enable_password password_source service_rc
  desired="${1:-false}"
  USER_OP_REASON=""
  USER_OP_PATH=""

  if [[ "${SUPPORT_USER_EXISTS:-false}" != "true" ]]; then
    if ! lookup_support_user; then
      USER_OP_REASON="${USER_LOOKUP_REASON:-support_user_lookup_failed}"
      return 1
    fi
  fi

  if [[ "${SUPPORT_USER_IS_OWNER}" == "true" ]]; then
    USER_OP_REASON="support_user_es_owner_no_permitido"
    return 1
  fi

  if set_support_user_active_via_core "${desired}"; then
    return 0
  fi
  core_reason="${USER_OP_REASON:-core_user_patch_failed}"

  if set_support_user_active_via_auth "${desired}"; then
    return 0
  fi
  core_reason="${USER_OP_REASON:-${core_reason}}"

  set +e
  set_support_user_active_via_service "${desired}"
  service_rc=$?
  set -e
  if (( service_rc == 0 )); then
    return 0
  fi
  if (( service_rc == 1 )); then
    core_reason="${USER_OP_REASON:-${core_reason}}"
  fi

  if [[ "${desired}" == "true" ]]; then
    # If lookup already confirms the user is active, treat enable as idempotent success
    # even when the API doesn't expose a stable user id for patching.
    if [[ "${SUPPORT_USER_ACTIVE_KNOWN}" == "true" && "${SUPPORT_USER_ACTIVE}" == "true" ]]; then
      USER_OP_REASON="already_true_known"
      return 0
    fi
    enable_password="$(resolve_support_enable_password)"
    if [[ -n "${SUPPORT_USER_PASSWORD:-}" ]]; then
      password_source="env"
    elif bashio::config.has_value "support_user_password"; then
      password_source="config"
    else
      password_source="derived_username"
    fi
    if [[ -z "${enable_password}" ]]; then
      USER_OP_REASON="${core_reason}"
      return 1
    fi
    if auth_user_with_password "${SUPPORT_USER_LOGIN_NAME}" "${enable_password}"; then
      SUPPORT_USER_ACTIVE="true"
      USER_OP_REASON="already_true"
      return 0
    fi
    if ! reset_user_password "${SUPPORT_USER_LOGIN_NAME}" "${enable_password}"; then
      USER_OP_REASON="reset_password_failed_enable_${password_source}"
      return 1
    fi
    if auth_user_with_password "${SUPPORT_USER_LOGIN_NAME}" "${enable_password}"; then
      SUPPORT_USER_ACTIVE="true"
      USER_OP_REASON="password_set_enable_${password_source}"
      return 0
    fi
    USER_OP_REASON="enable_verify_failed_${password_source}"
    return 1
  fi

  random_password="$(head -c 32 /dev/urandom 2>/dev/null | base64 2>/dev/null | tr -dc 'A-Za-z0-9' | head -c 32)"
  if [[ -z "${random_password}" ]]; then
    random_password="nodalia$(date +%s)$(od -An -N4 -tx4 /dev/urandom 2>/dev/null | tr -d ' \n' || true)"
  fi
  if ! reset_user_password "${SUPPORT_USER_LOGIN_NAME}" "${random_password}"; then
    USER_OP_REASON="reset_password_failed"
    return 1
  fi

  if ! verify_support_user_state false; then
    return 1
  fi

  SUPPORT_USER_ACTIVE_KNOWN="true"
  SUPPORT_USER_ACTIVE="false"
  USER_OP_REASON="password_rotated_disable_verified"
  return 0

}

audit_event() {
  local action reason details now
  action="${1:-unknown}"
  reason="${2:-}"
  details="${3:-}"
  now="$(now_utc)"
  jq -nc \
    --arg ts "${now}" \
    --arg action "${action}" \
    --arg reason "${reason}" \
    --arg details "${details}" \
    --arg actor "${SUPPORT_ACTOR:-ui}" \
    --arg target_id "${SUPPORT_TARGET_ID:-}" \
    --arg target_dns_suffix "${SUPPORT_TARGET_DNS_SUFFIX:-}" \
    --arg support_user "${SUPPORT_USER:-}" \
    --arg support_user_id "${SUPPORT_USER_ID:-}" \
    '{ts:$ts,action:$action,reason:$reason,details:$details,actor:$actor,target_id:$target_id,target_dns_suffix:$target_dns_suffix,support_user:$support_user,support_user_id:$support_user_id}' \
    >> "${AUDIT_FILE}"
}

read_meta() {
  local raw_epoch raw_ttl
  META_EXPIRES_EPOCH=0
  META_EXPIRES_AT=""
  META_TTL_MIN=0
  META_SUPPORT_USER=""
  if [[ -f "${META_FILE}" ]]; then
    raw_epoch="$(jq -r '.expires_epoch // 0' "${META_FILE}" 2>/dev/null || echo "0")"
    META_EXPIRES_EPOCH="$(sanitize_uint "${raw_epoch}")"
    META_EXPIRES_AT="$(jq -r '.expires_at // empty' "${META_FILE}" 2>/dev/null || true)"
    raw_ttl="$(jq -r '.ttl_minutes // 0' "${META_FILE}" 2>/dev/null || echo "0")"
    META_TTL_MIN="$(sanitize_uint "${raw_ttl}")"
    META_SUPPORT_USER="$(jq -r '.support_user // empty' "${META_FILE}" 2>/dev/null || true)"
  fi
}

prepare_meta() {
  local ttl now_epoch expires_epoch expires_at
  ttl="${1:-30}"
  if ! [[ "${ttl}" =~ ^[0-9]+$ ]]; then
    ttl="30"
  fi
  now_epoch="$(date +%s)"
  expires_epoch=$((now_epoch + ttl * 60))
  expires_at="$(date -u -r "${expires_epoch}" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || true)"
  if [[ -z "${expires_at}" ]]; then
    expires_at="$(date -u -d "@${expires_epoch}" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || true)"
  fi
  META_NEW_CREATED_AT="$(now_utc)"
  META_NEW_EXPIRES_EPOCH="${expires_epoch}"
  META_NEW_EXPIRES_AT="${expires_at}"
  META_NEW_TTL_MIN="${ttl}"
}

write_meta() {
  jq -nc \
    --arg created_at "${META_NEW_CREATED_AT}" \
    --arg expires_at "${META_NEW_EXPIRES_AT}" \
    --arg support_user "${SUPPORT_USER}" \
    --argjson expires_epoch "${META_NEW_EXPIRES_EPOCH}" \
    --argjson ttl_minutes "${META_NEW_TTL_MIN}" \
    '{created_at:$created_at,expires_at:$expires_at,expires_epoch:$expires_epoch,ttl_minutes:$ttl_minutes,support_user:$support_user}' > "${META_FILE}"
}

clear_meta() {
  rm -f "${META_FILE}"
}

build_eligibility() {
  local status_json support_enabled target_dns_suffix backend candidate_strings
  local self_dns_name magic_dns_suffix token_lc
  support_enabled=false
  if bashio::config.has_value "support_tunnel_enabled" && bashio::config.true "support_tunnel_enabled"; then
    support_enabled=true
  fi

  target_dns_suffix="$(normalize_dns_value "$(bashio::config "support_tailnet_dns_suffix" "tail37b857.ts.net")")"
  status_json="${SUPPORT_STATUS_JSON:-}"
  if [[ -z "${status_json}" ]]; then
    status_json=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')
  fi
  backend="$(jq -r '.BackendState // "Unknown"' <<< "${status_json}" 2>/dev/null || echo "Unknown")"
  self_dns_name="$(normalize_dns_value "$(jq -r '.Self.DNSName // empty' <<< "${status_json}" 2>/dev/null || true)")"
  magic_dns_suffix="$(normalize_dns_value "$(jq -r '.CurrentTailnet.MagicDNSSuffix // empty' <<< "${status_json}" 2>/dev/null || true)")"
  candidate_strings="$(jq -r '[.CurrentTailnet.Name,.CurrentTailnet.MagicDNSSuffix,.CurrentTailnet.Tailnet,.Self.DNSName,.Self.HostName,.Self.Tailnet] | map(select(type=="string" and length>0)) | .[]' <<< "${status_json}" 2>/dev/null || true)"

  SUPPORT_ENABLED="${support_enabled}"
  SUPPORT_TARGET_ID=""
  SUPPORT_TARGET_DNS_SUFFIX="${target_dns_suffix}"
  SUPPORT_BACKEND="${backend}"
  SUPPORT_REASON=""
  SUPPORT_TAILNET_MATCH="false"
  SUPPORT_USER="$(bashio::config "support_user" "nodalia")"

  SUPPORT_USER_EXISTS="false"
  SUPPORT_USER_ACTIVE="false"
  SUPPORT_USER_ACTIVE_KNOWN="false"
  SUPPORT_USER_IS_OWNER="false"
  SUPPORT_USER_ID=""
  SUPPORT_USER_LOGIN_NAME=""

  if [[ -z "${target_dns_suffix}" ]]; then
    SUPPORT_REASON="support_tailnet_dns_suffix_vacio"
    return
  fi

  if dns_matches_suffix "${self_dns_name}" "${target_dns_suffix}"; then
    SUPPORT_TAILNET_MATCH="true"
  elif dns_matches_suffix "${magic_dns_suffix}" "${target_dns_suffix}"; then
    SUPPORT_TAILNET_MATCH="true"
  else
    while IFS= read -r token; do
      token_lc="$(normalize_dns_value "${token}")"
      if dns_matches_suffix "${token_lc}" "${target_dns_suffix}"; then
        SUPPORT_TAILNET_MATCH="true"
        break
      fi
    done <<< "${candidate_strings}"
  fi

  if [[ "${support_enabled}" != "true" ]]; then
    SUPPORT_REASON="support_tunnel_enabled=false"
    return
  fi
  if [[ "${backend}" != "Running" ]]; then
    SUPPORT_REASON="backend_state=${backend}"
    return
  fi
  if [[ "${SUPPORT_TAILNET_MATCH}" != "true" ]]; then
    SUPPORT_REASON="tailnet_no_coincide_dns_soporte"
    return
  fi

  if ! lookup_support_user; then
    SUPPORT_REASON="${USER_LOOKUP_REASON:-support_user_lookup_failed}"
    return
  fi

  if [[ "${SUPPORT_USER_IS_OWNER}" == "true" ]]; then
    SUPPORT_REASON="support_user_es_owner_no_permitido"
    return
  fi
}

write_state() {
  local active eligible now
  active="${1:-false}"
  eligible="${2:-false}"
  now="$(now_utc)"
  read_meta

  jq -nc \
    --arg updated_at "${now}" \
    --arg support_target_id "${SUPPORT_TARGET_ID}" \
    --arg support_target_dns_suffix "${SUPPORT_TARGET_DNS_SUFFIX}" \
    --arg backend_state "${SUPPORT_BACKEND}" \
    --arg reason "${SUPPORT_REASON}" \
    --arg expires_at "${META_EXPIRES_AT}" \
    --arg support_user "${SUPPORT_USER}" \
    --arg support_user_id "${SUPPORT_USER_ID}" \
    --argjson expires_epoch "${META_EXPIRES_EPOCH}" \
    --argjson ttl_minutes "${META_TTL_MIN}" \
    --argjson support_enabled "$(json_bool "${SUPPORT_ENABLED}")" \
    --argjson tailnet_match "$(json_bool "${SUPPORT_TAILNET_MATCH}")" \
    --argjson eligible "$(json_bool "${eligible}")" \
    --argjson active "$(json_bool "${active}")" \
    --argjson support_user_exists "$(json_bool "${SUPPORT_USER_EXISTS}")" \
    --argjson support_user_active "$(json_bool "${SUPPORT_USER_ACTIVE}")" \
    --argjson support_user_active_known "$(json_bool "${SUPPORT_USER_ACTIVE_KNOWN}")" \
    --argjson support_user_is_owner "$(json_bool "${SUPPORT_USER_IS_OWNER}")" \
    '{
      updated_at:$updated_at,
      support_enabled:$support_enabled,
      support_target_id:$support_target_id,
      support_target_dns_suffix:$support_target_dns_suffix,
      backend_state:$backend_state,
      tailnet_match:$tailnet_match,
      eligible:$eligible,
      active:$active,
      support_user:$support_user,
      support_user_id:$support_user_id,
      support_user_exists:$support_user_exists,
      support_user_active:$support_user_active,
      support_user_active_known:$support_user_active_known,
      support_user_is_owner:$support_user_is_owner,
      pid:"",
      url:"",
      reason:$reason,
      expires_at:$expires_at,
      expires_epoch:$expires_epoch,
      ttl_minutes:$ttl_minutes
    }' > "${STATE_FILE}"
}

disable_running_access() {
  local reason details rc
  reason="${1:-manual_disable}"
  details=""
  rc=0

  if ! set_support_user_active false; then
    details="user_disable_error:${USER_OP_REASON}"
    rc=1
  else
    details="user_disable_ok:${USER_OP_REASON}"
  fi

  if (( rc == 0 )); then
    clear_meta
    audit_event "disabled" "${reason}" "${details}"
  else
    audit_event "disable_failed" "${reason}" "${details}"
  fi
  return "${rc}"
}

status_cmd() {
  local active eligible now_epoch
  build_eligibility
  read_meta

  active=false
  now_epoch="$(date +%s)"
  if [[ "${META_EXPIRES_EPOCH:-0}" -gt 0 ]]; then
    if (( now_epoch >= META_EXPIRES_EPOCH )); then
      if disable_running_access "ttl_expired" >/dev/null 2>&1; then
        SUPPORT_REASON="ttl_expired"
        active=false
      else
        SUPPORT_REASON="ttl_expired_disable_failed:${USER_OP_REASON:-disable_failed}"
        active=true
      fi
    elif [[ "${SUPPORT_USER_EXISTS}" == "true" ]]; then
      if [[ "${SUPPORT_USER_ACTIVE_KNOWN}" != "true" ]]; then
        active=true
      elif [[ "${SUPPORT_USER_ACTIVE}" == "true" ]]; then
        active=true
      else
        clear_meta
        SUPPORT_REASON="support_user_inactivo_sin_sesion"
        active=false
      fi
    else
      # If support user lookup couldn't run in this cycle (e.g. backend state gate),
      # preserve the active window until we can verify user state again.
      active=true
    fi
  fi

  eligible=false
  if [[ "${SUPPORT_ENABLED}" == "true" && "${SUPPORT_TAILNET_MATCH}" == "true" && "${SUPPORT_BACKEND}" == "Running" ]] && \
    [[ "${SUPPORT_USER_EXISTS}" == "true" && "${SUPPORT_USER_IS_OWNER}" != "true" ]]; then
    eligible=true
  fi

  write_state "${active}" "${eligible}"
  cat "${STATE_FILE}"
}

enable_cmd() {
  local ttl_minutes details
  build_eligibility

  if [[ "${SUPPORT_ENABLED}" != "true" || "${SUPPORT_TAILNET_MATCH}" != "true" || "${SUPPORT_BACKEND}" != "Running" ]] || \
    [[ "${SUPPORT_USER_EXISTS}" != "true" || "${SUPPORT_USER_IS_OWNER}" == "true" ]]; then
    write_state false false
    jq -nc \
      --arg error "support access no permitido en este estado" \
      --arg reason "${SUPPORT_REASON:-support_not_eligible}" \
      '{ok:false,error:$error,reason:$reason}'
    exit 1
  fi

  read_meta
  if [[ "${META_EXPIRES_EPOCH:-0}" -gt 0 ]]; then
    if [[ "${SUPPORT_USER_ACTIVE}" == "true" ]] && (( $(date +%s) < META_EXPIRES_EPOCH )); then
      write_state true true
      cat "${STATE_FILE}"
      exit 0
    fi
  fi

  if ! set_support_user_active true; then
    SUPPORT_REASON="${USER_OP_REASON}"
    write_state false true
    jq -nc \
      --arg error "no se pudo habilitar support_user" \
      --arg reason "${USER_OP_REASON:-enable_failed}" \
      --arg lookup_source "${USER_LOOKUP_SOURCE:-}" \
      --arg lookup_reason "${USER_LOOKUP_REASON:-}" \
      --arg support_user "${SUPPORT_USER:-}" \
      --arg support_user_id "${SUPPORT_USER_ID:-}" \
      --arg support_user_login_name "${SUPPORT_USER_LOGIN_NAME:-}" \
      --arg op_path "${USER_OP_PATH:-}" \
      '{ok:false,error:$error,reason:$reason,lookup_source:$lookup_source,lookup_reason:$lookup_reason,support_user:$support_user,support_user_id:$support_user_id,support_user_login_name:$support_user_login_name,op_path:$op_path}'
    exit 1
  fi

  ttl_minutes="$(bashio::config "support_tunnel_ttl_minutes" "30")"
  prepare_meta "${ttl_minutes}"
  write_meta

  details="user_enable_ok:${USER_OP_REASON}"
  audit_event "enabled" "ok" "${details}"
  write_state true true
  cat "${STATE_FILE}"
}

disable_cmd() {
  build_eligibility

  if ! disable_running_access "manual_disable"; then
    SUPPORT_REASON="${USER_OP_REASON:-disable_failed}"
    status_cmd >/dev/null 2>&1 || true
    jq -nc \
      --arg error "no se pudo revocar support_user" \
      --arg reason "${USER_OP_REASON:-disable_failed}" \
      --arg support_user "${SUPPORT_USER:-}" \
      --arg support_user_id "${SUPPORT_USER_ID:-}" \
      --arg support_user_login_name "${SUPPORT_USER_LOGIN_NAME:-}" \
      --arg op_path "${USER_OP_PATH:-}" \
      --arg lookup_source "${USER_LOOKUP_SOURCE:-}" \
      --arg lookup_reason "${USER_LOOKUP_REASON:-}" \
      '{ok:false,error:$error,reason:$reason,support_user:$support_user,support_user_id:$support_user_id,support_user_login_name:$support_user_login_name,op_path:$op_path,lookup_source:$lookup_source,lookup_reason:$lookup_reason}'
    exit 1
  fi

  SUPPORT_REASON="manual_disable"
  write_state false false
  cat "${STATE_FILE}"
}

audit_cmd() {
  if [[ -f "${AUDIT_FILE}" ]]; then
    tail -n 100 "${AUDIT_FILE}"
  else
    echo ""
  fi
}

debug_cmd() {
  local cfg_enabled cfg_dns cfg_user cfg_password cfg_password_set
  local cfg_enable_service cfg_disable_service
  local status_json self_dns_name self_host_name magic_dns_suffix current_tailnet_name
  local lookup_forced lookup_rc lookup_hint
  local debug_eligible now_epoch debug_active
  local state_snapshot meta_snapshot

  cfg_enabled=false
  if bashio::config.has_value "support_tunnel_enabled" && bashio::config.true "support_tunnel_enabled"; then
    cfg_enabled=true
  fi
  cfg_dns="$(normalize_dns_value "$(bashio::config "support_tailnet_dns_suffix" "tail37b857.ts.net")")"
  cfg_user="$(bashio::config "support_user" "nodalia")"
  cfg_password="$(bashio::config "support_user_password" "" 2>/dev/null || true)"
  cfg_enable_service="$(trim_spaces "$(bashio::config "support_enable_service" "" 2>/dev/null || true)")"
  cfg_disable_service="$(trim_spaces "$(bashio::config "support_disable_service" "" 2>/dev/null || true)")"
  cfg_password_set=false
  if [[ -n "${cfg_password}" ]]; then
    cfg_password_set=true
  fi

  status_json=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')
  SUPPORT_STATUS_JSON="${status_json}"
  build_eligibility
  read_meta

  lookup_forced=false
  lookup_rc="skipped"
  lookup_hint="lookup_skip_backend_not_running"
  if [[ "${SUPPORT_BACKEND:-Unknown}" == "Running" ]]; then
    lookup_forced=true
    lookup_hint="lookup_ran"
    set +e
    lookup_support_user
    lookup_rc=$?
    set -e
  fi

  debug_eligible=false
  if [[ "${SUPPORT_ENABLED}" == "true" && "${SUPPORT_TAILNET_MATCH}" == "true" && "${SUPPORT_BACKEND}" == "Running" ]] && \
    [[ "${SUPPORT_USER_EXISTS}" == "true" && "${SUPPORT_USER_IS_OWNER}" != "true" ]]; then
    debug_eligible=true
  fi

  now_epoch="$(date +%s)"
  debug_active=false
  if [[ "${META_EXPIRES_EPOCH:-0}" -gt 0 && "${now_epoch}" -lt "${META_EXPIRES_EPOCH}" ]]; then
    debug_active=true
  fi

  self_dns_name="$(jq -r '.Self.DNSName // empty' <<< "${status_json}" 2>/dev/null || true)"
  self_host_name="$(jq -r '.Self.HostName // empty' <<< "${status_json}" 2>/dev/null || true)"
  magic_dns_suffix="$(jq -r '.CurrentTailnet.MagicDNSSuffix // empty' <<< "${status_json}" 2>/dev/null || true)"
  current_tailnet_name="$(jq -r '.CurrentTailnet.Name // empty' <<< "${status_json}" 2>/dev/null || true)"

  state_snapshot="$(read_json_file_or_empty "${STATE_FILE}")"
  meta_snapshot="$(read_json_file_or_empty "${META_FILE}")"

  jq -nc \
    --arg generated_at "$(now_utc)" \
    --arg cfg_dns "${cfg_dns}" \
    --arg cfg_user "${cfg_user}" \
    --arg cfg_enable_service "${cfg_enable_service}" \
    --arg cfg_disable_service "${cfg_disable_service}" \
    --arg backend_state "${SUPPORT_BACKEND:-Unknown}" \
    --arg support_reason "${SUPPORT_REASON:-}" \
    --arg support_user "${SUPPORT_USER:-}" \
    --arg support_user_id "${SUPPORT_USER_ID:-}" \
    --arg support_user_login_name "${SUPPORT_USER_LOGIN_NAME:-}" \
    --arg lookup_rc "${lookup_rc}" \
    --arg lookup_source "${USER_LOOKUP_SOURCE:-}" \
    --arg lookup_reason "${USER_LOOKUP_REASON:-}" \
    --arg lookup_hint "${lookup_hint}" \
    --arg core_users_endpoint "${CORE_USERS_ENDPOINT_USED:-}" \
    --arg auth_users_endpoint "${AUTH_USERS_ENDPOINT_USED:-}" \
    --arg user_op_reason "${USER_OP_REASON:-}" \
    --arg user_op_path "${USER_OP_PATH:-}" \
    --arg self_dns_name "${self_dns_name}" \
    --arg self_host_name "${self_host_name}" \
    --arg magic_dns_suffix "${magic_dns_suffix}" \
    --arg current_tailnet_name "${current_tailnet_name}" \
    --arg api_last_rc "${API_LAST_RC:-}" \
    --arg api_last_output "${API_LAST_OUTPUT:-}" \
    --arg api_last_stderr "${API_LAST_STDERR:-}" \
    --argjson cfg_enabled "$(json_bool "${cfg_enabled}")" \
    --argjson cfg_password_set "$(json_bool "${cfg_password_set}")" \
    --argjson tailnet_match "$(json_bool "${SUPPORT_TAILNET_MATCH:-false}")" \
    --argjson eligible "$(json_bool "${debug_eligible}")" \
    --argjson active "$(json_bool "${debug_active}")" \
    --argjson support_user_exists "$(json_bool "${SUPPORT_USER_EXISTS:-false}")" \
    --argjson support_user_active "$(json_bool "${SUPPORT_USER_ACTIVE:-false}")" \
    --argjson support_user_active_known "$(json_bool "${SUPPORT_USER_ACTIVE_KNOWN:-false}")" \
    --argjson support_user_is_owner "$(json_bool "${SUPPORT_USER_IS_OWNER:-false}")" \
    --argjson lookup_forced "$(json_bool "${lookup_forced}")" \
    --argjson state_snapshot "${state_snapshot}" \
    --argjson meta_snapshot "${meta_snapshot}" \
    '{
      ok:true,
      action:"debug",
      generated_at:$generated_at,
      config:{
        support_tunnel_enabled:$cfg_enabled,
        support_tailnet_dns_suffix:$cfg_dns,
        support_user:$cfg_user,
        support_user_password_set:$cfg_password_set,
        support_enable_service:$cfg_enable_service,
        support_disable_service:$cfg_disable_service
      },
      tailscale:{
        backend_state:$backend_state,
        self_dns_name:$self_dns_name,
        self_host_name:$self_host_name,
        current_tailnet_name:$current_tailnet_name,
        magic_dns_suffix:$magic_dns_suffix
      },
      support:{
        reason:$support_reason,
        tailnet_match:$tailnet_match,
        eligible:$eligible,
        active:$active,
        support_user:$support_user,
        support_user_id:$support_user_id,
        support_user_login_name:$support_user_login_name,
        support_user_exists:$support_user_exists,
        support_user_active:$support_user_active,
        support_user_active_known:$support_user_active_known,
        support_user_is_owner:$support_user_is_owner
      },
      lookup:{
        forced:$lookup_forced,
        rc:$lookup_rc,
        source:$lookup_source,
        reason:$lookup_reason,
        hint:$lookup_hint,
        core_users_endpoint:$core_users_endpoint,
        auth_users_endpoint:$auth_users_endpoint
      },
      op:{
        reason:$user_op_reason,
        path:$user_op_path
      },
      api_last:{
        rc:$api_last_rc,
        stderr:$api_last_stderr,
        output:$api_last_output
      },
      state_snapshot:$state_snapshot,
      meta_snapshot:$meta_snapshot
    }'
}

fallback_status_json() {
  local reason cfg_dns cfg_user cfg_enabled
  reason="${1:-support_status_failed}"
  cfg_dns="$(bashio::config "support_tailnet_dns_suffix" 2>/dev/null || true)"
  if [[ -z "${cfg_dns}" ]]; then
    cfg_dns="tail37b857.ts.net"
  fi
  cfg_user="$(bashio::config "support_user" 2>/dev/null || true)"
  if [[ -z "${cfg_user}" ]]; then
    cfg_user="nodalia"
  fi
  cfg_enabled=false
  if bashio::config.has_value "support_tunnel_enabled" && bashio::config.true "support_tunnel_enabled"; then
    cfg_enabled=true
  fi
  jq -nc \
    --arg updated_at "$(now_utc)" \
    --arg support_target_dns_suffix "${cfg_dns}" \
    --arg support_user "${cfg_user}" \
    --arg reason "${reason}" \
    --argjson support_enabled "$(json_bool "${cfg_enabled}")" \
    '{
      updated_at:$updated_at,
      support_enabled:$support_enabled,
      support_target_id:"",
      support_target_dns_suffix:$support_target_dns_suffix,
      backend_state:"Unknown",
      tailnet_match:false,
      eligible:false,
      active:false,
      support_user:$support_user,
      support_user_id:"",
      support_user_exists:false,
      support_user_active:false,
      support_user_active_known:false,
      support_user_is_owner:false,
      pid:"",
      url:"",
      reason:$reason,
      expires_at:"",
      expires_epoch:0,
      ttl_minutes:0
    }'
}

case "${1:-status}" in
  status)
    if ! status_cmd; then
      fallback_status_json "support_status_failed"
      exit 0
    fi
    ;;
  enable)
    enable_cmd
    ;;
  disable)
    disable_cmd
    ;;
  audit)
    audit_cmd
    ;;
  debug)
    if ! debug_cmd; then
      jq -nc \
        --arg error "support_debug_failed" \
        --arg output "${API_LAST_OUTPUT:-}" \
        '{ok:false,action:"debug",error:$error,output:$output}'
      exit 0
    fi
    ;;
  *)
    echo "Usage: support-tunnel [status|enable|disable|audit|debug]" >&2
    exit 2
    ;;
esac
