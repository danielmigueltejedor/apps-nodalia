#!/command/with-contenv bashio
# shellcheck shell=bash
# ==============================================================================
# Home Assistant App: Tailscale (Nodalia Beta)
# Support access manager (temporary Nodalia support window)
# ==============================================================================
set -euo pipefail

readonly STATE_FILE="/data/support-tunnel.json"
readonly META_FILE="/data/support-tunnel-meta.json"
readonly AUDIT_FILE="/data/support-tunnel-audit.log"

now_utc() {
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

json_bool() {
  if [[ "${1:-false}" == "true" ]]; then
    echo "true"
  else
    echo "false"
  fi
}

normalize_dns_value() {
  local value
  value="${1:-}"
  value="$(printf '%s' "${value}" | tr '[:upper:]' '[:lower:]')"
  value="${value#.}"
  value="${value%.}"
  printf '%s' "${value}"
}

dns_matches_suffix() {
  local value suffix
  value="$(normalize_dns_value "${1:-}")"
  suffix="$(normalize_dns_value "${2:-}")"
  if [[ -z "${value}" || -z "${suffix}" ]]; then
    return 1
  fi
  [[ "${value}" == "${suffix}" || "${value}" == *."${suffix}" ]]
}

is_valid_service_ref() {
  local ref
  ref="${1:-}"
  [[ "${ref}" =~ ^[a-z_][a-z0-9_]*\.[a-z_][a-z0-9_]*$ ]]
}

split_service_ref() {
  local ref
  ref="${1:-}"
  if ! is_valid_service_ref "${ref}"; then
    return 1
  fi
  SERVICE_DOMAIN="${ref%%.*}"
  SERVICE_NAME="${ref#*.}"
  return 0
}

audit_event() {
  local action reason details now
  action="${1:-unknown}"
  reason="${2:-}"
  details="${3:-}"
  now="$(now_utc)"
  jq -nc \
    --arg ts "${now}" \
    --arg action "${action}" \
    --arg reason "${reason}" \
    --arg details "${details}" \
    --arg actor "${SUPPORT_ACTOR:-ui}" \
    --arg target_id "${SUPPORT_TARGET_ID:-}" \
    --arg target_dns_suffix "${SUPPORT_TARGET_DNS_SUFFIX:-}" \
    --arg support_user "${SUPPORT_USER:-}" \
    '{ts:$ts,action:$action,reason:$reason,details:$details,actor:$actor,target_id:$target_id,target_dns_suffix:$target_dns_suffix,support_user:$support_user}' \
    >> "${AUDIT_FILE}"
}

read_meta() {
  META_CREATED_AT=""
  META_EXPIRES_EPOCH=0
  META_EXPIRES_AT=""
  META_TTL_MIN=0
  META_SUPPORT_USER=""
  if [[ -f "${META_FILE}" ]]; then
    META_CREATED_AT="$(jq -r '.created_at // empty' "${META_FILE}" 2>/dev/null || true)"
    META_EXPIRES_EPOCH="$(jq -r '.expires_epoch // 0' "${META_FILE}" 2>/dev/null || echo "0")"
    META_EXPIRES_AT="$(jq -r '.expires_at // empty' "${META_FILE}" 2>/dev/null || true)"
    META_TTL_MIN="$(jq -r '.ttl_minutes // 0' "${META_FILE}" 2>/dev/null || echo "0")"
    META_SUPPORT_USER="$(jq -r '.support_user // empty' "${META_FILE}" 2>/dev/null || true)"
  fi
}

prepare_meta() {
  local ttl now_epoch expires_epoch expires_at
  ttl="${1:-30}"
  if ! [[ "${ttl}" =~ ^[0-9]+$ ]]; then
    ttl="30"
  fi
  now_epoch="$(date +%s)"
  expires_epoch=$((now_epoch + ttl * 60))
  expires_at="$(date -u -r "${expires_epoch}" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || true)"
  if [[ -z "${expires_at}" ]]; then
    expires_at="$(date -u -d "@${expires_epoch}" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || true)"
  fi
  META_NEW_CREATED_AT="$(now_utc)"
  META_NEW_EXPIRES_EPOCH="${expires_epoch}"
  META_NEW_EXPIRES_AT="${expires_at}"
  META_NEW_TTL_MIN="${ttl}"
}

write_meta() {
  jq -nc \
    --arg created_at "${META_NEW_CREATED_AT}" \
    --arg expires_at "${META_NEW_EXPIRES_AT}" \
    --arg support_user "${SUPPORT_USER}" \
    --argjson expires_epoch "${META_NEW_EXPIRES_EPOCH}" \
    --argjson ttl_minutes "${META_NEW_TTL_MIN}" \
    '{created_at:$created_at,expires_at:$expires_at,expires_epoch:$expires_epoch,ttl_minutes:$ttl_minutes,support_user:$support_user}' > "${META_FILE}"
}

clear_meta() {
  rm -f "${META_FILE}"
}

invoke_service() {
  local service_ref action_reason ttl_minutes expires_at payload response rc
  service_ref="${1:-}"
  action_reason="${2:-manual}"
  ttl_minutes="${3:-0}"
  expires_at="${4:-}"

  if [[ -z "${service_ref}" ]]; then
    SERVICE_LAST_OUTPUT="service_not_configured"
    return 1
  fi
  if ! split_service_ref "${service_ref}"; then
    SERVICE_LAST_OUTPUT="invalid_service_ref:${service_ref}"
    return 1
  fi

  payload="$(jq -nc \
    --arg source "tailscale_nodalia_beta" \
    --arg action_reason "${action_reason}" \
    --arg support_user "${SUPPORT_USER}" \
    --arg backend_state "${SUPPORT_BACKEND}" \
    --arg target_dns_suffix "${SUPPORT_TARGET_DNS_SUFFIX}" \
    --arg expires_at "${expires_at}" \
    --argjson ttl_minutes "${ttl_minutes}" \
    '{source:$source,action_reason:$action_reason,support_user:$support_user,backend_state:$backend_state,target_dns_suffix:$target_dns_suffix,expires_at:$expires_at,ttl_minutes:$ttl_minutes}')"

  set +e
  response="$(bashio::api.supervisor POST "/core/api/services/${SERVICE_DOMAIN}/${SERVICE_NAME}" "${payload}" 2>&1)"
  rc=$?
  set -e

  SERVICE_LAST_OUTPUT="$(printf '%s' "${response}" | tail -c 1400)"
  if (( rc != 0 )); then
    return 1
  fi
  return 0
}

build_eligibility() {
  local status_json support_enabled target_dns_suffix backend candidate_strings
  local self_dns_name magic_dns_suffix token_lc
  support_enabled=false
  if bashio::config.has_value "support_tunnel_enabled" && bashio::config.true "support_tunnel_enabled"; then
    support_enabled=true
  fi

  # support_tailnet_id is kept for backward compatibility only.
  # Eligibility is based exclusively on DNS suffix matching.
  target_dns_suffix="$(normalize_dns_value "$(bashio::config "support_tailnet_dns_suffix" "tail37b857.ts.net")")"
  status_json="${SUPPORT_STATUS_JSON:-}"
  if [[ -z "${status_json}" ]]; then
    status_json=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')
  fi
  backend="$(jq -r '.BackendState // "Unknown"' <<< "${status_json}" 2>/dev/null || echo "Unknown")"
  self_dns_name="$(normalize_dns_value "$(jq -r '.Self.DNSName // empty' <<< "${status_json}" 2>/dev/null || true)")"
  magic_dns_suffix="$(normalize_dns_value "$(jq -r '.CurrentTailnet.MagicDNSSuffix // empty' <<< "${status_json}" 2>/dev/null || true)")"
  candidate_strings="$(jq -r '[.CurrentTailnet.Name,.CurrentTailnet.MagicDNSSuffix,.CurrentTailnet.Tailnet,.Self.DNSName,.Self.HostName,.Self.Tailnet] | map(select(type=="string" and length>0)) | .[]' <<< "${status_json}" 2>/dev/null || true)"

  SUPPORT_ENABLED="${support_enabled}"
  SUPPORT_TARGET_ID=""
  SUPPORT_TARGET_DNS_SUFFIX="${target_dns_suffix}"
  SUPPORT_TARGET_URL="$(bashio::config "support_target_url" "http://127.0.0.1:8123")"
  SUPPORT_BACKEND="${backend}"
  SUPPORT_TAILNET_MATCH="false"
  SUPPORT_REASON=""
  SUPPORT_USER="$(bashio::config "support_user" "Nodalia")"
  SUPPORT_ENABLE_SERVICE="$(bashio::config "support_enable_service" "")"
  SUPPORT_DISABLE_SERVICE="$(bashio::config "support_disable_service" "")"

  if [[ -z "${target_dns_suffix}" ]]; then
    SUPPORT_REASON="support_tailnet_dns_suffix vacio"
    return
  fi

  if dns_matches_suffix "${self_dns_name}" "${target_dns_suffix}"; then
    SUPPORT_TAILNET_MATCH="true"
  elif dns_matches_suffix "${magic_dns_suffix}" "${target_dns_suffix}"; then
    SUPPORT_TAILNET_MATCH="true"
  else
    while IFS= read -r token; do
      token_lc="$(normalize_dns_value "${token}")"
      if dns_matches_suffix "${token_lc}" "${target_dns_suffix}"; then
        SUPPORT_TAILNET_MATCH="true"
        break
      fi
    done <<< "${candidate_strings}"
  fi

  if [[ "${support_enabled}" != "true" ]]; then
    SUPPORT_REASON="support_tunnel_enabled=false"
    return
  fi
  if [[ "${backend}" != "Running" ]]; then
    SUPPORT_REASON="backend_state=${backend}"
    return
  fi
  if [[ "${SUPPORT_TAILNET_MATCH}" != "true" ]]; then
    SUPPORT_REASON="tailnet no coincide con dns suffix de soporte"
    return
  fi
  if [[ -z "${SUPPORT_ENABLE_SERVICE}" ]]; then
    SUPPORT_REASON="support_enable_service vacio"
    return
  fi
  if ! is_valid_service_ref "${SUPPORT_ENABLE_SERVICE}"; then
    SUPPORT_REASON="support_enable_service invalido"
    return
  fi
  if [[ -n "${SUPPORT_DISABLE_SERVICE}" ]] && ! is_valid_service_ref "${SUPPORT_DISABLE_SERVICE}"; then
    SUPPORT_REASON="support_disable_service invalido"
    return
  fi
}

write_state() {
  local active eligible now
  active="${1:-false}"
  eligible="${2:-false}"
  now="$(now_utc)"
  read_meta
  jq -nc \
    --arg updated_at "${now}" \
    --arg support_target_id "${SUPPORT_TARGET_ID}" \
    --arg support_target_dns_suffix "${SUPPORT_TARGET_DNS_SUFFIX}" \
    --arg backend_state "${SUPPORT_BACKEND}" \
    --arg support_target_url "${SUPPORT_TARGET_URL}" \
    --arg reason "${SUPPORT_REASON}" \
    --arg expires_at "${META_EXPIRES_AT}" \
    --arg support_user "${SUPPORT_USER}" \
    --arg support_enable_service "${SUPPORT_ENABLE_SERVICE}" \
    --arg support_disable_service "${SUPPORT_DISABLE_SERVICE}" \
    --argjson expires_epoch "${META_EXPIRES_EPOCH}" \
    --argjson ttl_minutes "${META_TTL_MIN}" \
    --argjson support_enabled "$(json_bool "${SUPPORT_ENABLED}")" \
    --argjson tailnet_match "$(json_bool "${SUPPORT_TAILNET_MATCH}")" \
    --argjson eligible "$(json_bool "${eligible}")" \
    --argjson active "$(json_bool "${active}")" \
    '{
      updated_at: $updated_at,
      support_enabled: $support_enabled,
      support_target_id: $support_target_id,
      support_target_dns_suffix: $support_target_dns_suffix,
      support_target_url: $support_target_url,
      backend_state: $backend_state,
      tailnet_match: $tailnet_match,
      eligible: $eligible,
      active: $active,
      support_user: $support_user,
      support_enable_service: $support_enable_service,
      support_disable_service: $support_disable_service,
      pid: "",
      url: "",
      reason: $reason,
      expires_at: $expires_at,
      expires_epoch: $expires_epoch,
      ttl_minutes: $ttl_minutes
    }' > "${STATE_FILE}"
}

disable_running_access() {
  local reason details ttl expires_at disable_rc
  reason="${1:-manual_disable}"
  details=""
  read_meta
  ttl="${META_TTL_MIN:-0}"
  expires_at="${META_EXPIRES_AT:-}"

  disable_rc=0
  if [[ -n "${SUPPORT_DISABLE_SERVICE}" ]]; then
    if invoke_service "${SUPPORT_DISABLE_SERVICE}" "${reason}" "${ttl}" "${expires_at}"; then
      details="disable_service=ok"
    else
      details="disable_service=error:${SERVICE_LAST_OUTPUT}"
      disable_rc=1
    fi
  else
    details="disable_service=skipped"
  fi

  clear_meta
  audit_event "disabled" "${reason}" "${details}"
  return "${disable_rc}"
}

status_cmd() {
  local active eligible now_epoch
  build_eligibility
  read_meta

  active=false
  now_epoch="$(date +%s)"
  if [[ "${META_EXPIRES_EPOCH:-0}" -gt 0 ]]; then
    if (( now_epoch < META_EXPIRES_EPOCH )); then
      active=true
      if [[ -n "${META_SUPPORT_USER}" ]]; then
        SUPPORT_USER="${META_SUPPORT_USER}"
      fi
    else
      disable_running_access "ttl_expired" >/dev/null 2>&1 || true
      active=false
      SUPPORT_REASON="ttl_expired"
    fi
  fi

  eligible=false
  if [[ "${SUPPORT_ENABLED}" == "true" && "${SUPPORT_TAILNET_MATCH}" == "true" && "${SUPPORT_BACKEND}" == "Running" ]] && \
    [[ -n "${SUPPORT_ENABLE_SERVICE}" ]] && is_valid_service_ref "${SUPPORT_ENABLE_SERVICE}"; then
    if [[ -z "${SUPPORT_DISABLE_SERVICE}" ]] || is_valid_service_ref "${SUPPORT_DISABLE_SERVICE}"; then
      eligible=true
    fi
  fi

  write_state "${active}" "${eligible}"
  cat "${STATE_FILE}"
}

enable_cmd() {
  local ttl_minutes
  build_eligibility
  if [[ "${SUPPORT_ENABLED}" != "true" || "${SUPPORT_TAILNET_MATCH}" != "true" || "${SUPPORT_BACKEND}" != "Running" ]]; then
    write_state false false
    echo '{"ok":false,"error":"support access no permitido en este estado"}'
    exit 1
  fi
  if [[ -z "${SUPPORT_ENABLE_SERVICE}" ]] || ! is_valid_service_ref "${SUPPORT_ENABLE_SERVICE}"; then
    SUPPORT_REASON="support_enable_service no configurado"
    write_state false false
    echo '{"ok":false,"error":"support_enable_service no configurado"}'
    exit 1
  fi
  if [[ -n "${SUPPORT_DISABLE_SERVICE}" ]] && ! is_valid_service_ref "${SUPPORT_DISABLE_SERVICE}"; then
    SUPPORT_REASON="support_disable_service invalido"
    write_state false false
    echo '{"ok":false,"error":"support_disable_service invalido"}'
    exit 1
  fi

  status_snapshot="$(status_cmd)"
  if [[ "$(jq -r '.active // false' <<< "${status_snapshot}" 2>/dev/null || echo "false")" == "true" ]]; then
    printf '%s\n' "${status_snapshot}"
    exit 0
  fi

  ttl_minutes="$(bashio::config "support_tunnel_ttl_minutes" "30")"
  prepare_meta "${ttl_minutes}"

  if ! invoke_service "${SUPPORT_ENABLE_SERVICE}" "enable" "${META_NEW_TTL_MIN}" "${META_NEW_EXPIRES_AT}"; then
    SUPPORT_REASON="support_enable_service fallo"
    audit_event "enable_failed" "service_error" "${SERVICE_LAST_OUTPUT}"
    write_state false false
    echo '{"ok":false,"error":"fallo al activar acceso de soporte"}'
    exit 1
  fi

  write_meta
  audit_event "enabled" "ok" "enable_service=ok"
  write_state true true
  cat "${STATE_FILE}"
}

disable_cmd() {
  build_eligibility
  disable_running_access "manual_disable" >/dev/null 2>&1 || true
  SUPPORT_REASON="manual_disable"
  write_state false false
  cat "${STATE_FILE}"
}

audit_cmd() {
  if [[ -f "${AUDIT_FILE}" ]]; then
    tail -n 100 "${AUDIT_FILE}"
  else
    echo ""
  fi
}

case "${1:-status}" in
  status)
    status_cmd
    ;;
  enable)
    enable_cmd
    ;;
  disable)
    disable_cmd
    ;;
  audit)
    audit_cmd
    ;;
  *)
    echo "Usage: support-tunnel [status|enable|disable|audit]" >&2
    exit 2
    ;;
esac
