#!/command/with-contenv bashio
# shellcheck shell=bash
set -euo pipefail

# This script performs a local identity reset ("logauth") for the add-on.
# Goal: make the node require login again so the user can join a different tailnet
# without uninstalling/reinstalling the add-on.
#
# Important: we don't use tailscale.com public API here. Everything is local:
# - tailscale localapi via the unix socket
# - wiping /data state files (like uninstall)
# - re-running post-tailscaled to regenerate AuthURL.

SOCK="/var/run/tailscale/tailscaled.sock"
STATE="/data/tailscaled.state"
STATEDIR="/data/state"
LOCK_FILE="/data/tailscale-reset.lock"

log() {
  printf '[logauth-reset] %s\n' "$*"
}

cleanup_lock() {
  rm -f "${LOCK_FILE}" 2>/dev/null || true
}
trap cleanup_lock EXIT

list_tailscaled_pids() {
  local pids=""
  pids="$(pidof tailscaled 2>/dev/null || true)"
  if [[ -z "${pids}" ]] && command -v pgrep > /dev/null 2>&1; then
    pids="$(pgrep -x tailscaled 2>/dev/null | tr '\n' ' ' || true)"
  fi
  printf '%s' "${pids}"
}

stop_tailscaled_signal() {
  local signal_name="${1:-INT}"
  local attempts="${2:-8}"
  local i
  local pids
  for ((i=1; i<=attempts; i++)); do
    pids="$(list_tailscaled_pids)"
    if [[ -z "${pids}" ]]; then
      if [[ ! -S "${SOCK}" ]]; then
        return 0
      fi
      rm -f "${SOCK}" 2>/dev/null || true
      if [[ ! -S "${SOCK}" ]]; then
        return 0
      fi
    else
      log "Sending SIG${signal_name} to tailscaled pids=${pids} (attempt ${i}/${attempts})"
      kill -"${signal_name}" ${pids} 2>/dev/null || true
    fi
    sleep 1
  done
  return 1
}

log "Acquiring reset lock: ${LOCK_FILE}"
printf '%s\n' "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" > "${LOCK_FILE}" 2>/dev/null || true
chmod 0600 "${LOCK_FILE}" 2>/dev/null || true
sync 2>/dev/null || true

if [[ -S "${SOCK}" ]]; then
  log "Bringing Tailscale down (best-effort)..."
  timeout 8 /opt/tailscale --socket="${SOCK}" down 2>/dev/null || true

  log "Logging out (best-effort)..."
  timeout 8 /opt/tailscale --socket="${SOCK}" logout 2>/dev/null || true
else
  log "Socket not present yet; skipping tailscale down/logout pre-flight"
fi

# Avoid SIGTERM: tailscaled/finish halts the whole add-on on signal 15.
# Use SIGINT first, then SIGKILL as fallback; keep retrying in case s6 respawns
# briefly before honoring the reset lock.
if [[ -n "$(list_tailscaled_pids)" ]] || [[ -S "${SOCK}" ]]; then
  stop_tailscaled_signal INT 10 || true
fi
if [[ -n "$(list_tailscaled_pids)" ]] || [[ -S "${SOCK}" ]]; then
  stop_tailscaled_signal KILL 8 || true
fi

daemon_pids="$(list_tailscaled_pids)"
if [[ -S "${SOCK}" ]]; then
  rm -f "${SOCK}" 2>/dev/null || true
fi
log "socket present after stop=$([[ -S "${SOCK}" ]] && echo true || echo false) pids=$([[ -n "${daemon_pids}" ]] && echo "${daemon_pids}" || echo none)"

if [[ -n "${daemon_pids}" ]]; then
  log "Abort reset: unable to stop tailscaled cleanly."
  exit 1
fi

log "Removing local auth/state files"
rm -f "${STATE}"
rm -rf "${STATEDIR}"
rm -f /data/tailscale-onboarding.json /data/tailscale-runtime.json /data/tailscale-login-notified
rm -rf /var/lib/tailscale 2>/dev/null || true
mkdir -p /var/lib/tailscale 2>/dev/null || true
mkdir -p "${STATEDIR}"
chmod 0700 "${STATEDIR}" 2>/dev/null || true

log "Releasing reset lock"
cleanup_lock

log "Waiting for tailscaled socket to return..."
for ((i=0; i<25; i++)); do
  if [[ -S "${SOCK}" ]]; then
    break
  fi
  sleep 1
done
log "socket present after restart=$([[ -S "${SOCK}" ]] && echo true || echo false)"

log "Re-running post-tailscaled to apply config and regenerate AuthURL"
set +e
post_output="$(timeout 45 /etc/s6-overlay/s6-rc.d/post-tailscaled/run 2>&1)"
post_rc=$?
set -e
log "post-tailscaled rc=${post_rc}"
if [[ -n "${post_output}" ]]; then
  printf '%s\n' "${post_output}" | tail -n 80
fi

status_json="$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')"
backend_state="$(jq -r '.BackendState // "Unknown"' <<< "${status_json}" 2>/dev/null || echo "Unknown")"
auth_url="$(jq -r '.AuthURL // .Self.AuthURL // empty' <<< "${status_json}" 2>/dev/null || true)"

if [[ "${backend_state}" == "Running" ]] && [[ -z "${auth_url}" ]]; then
  log "Backend still Running; forcing interactive reauth (tailscale up --reset --force-reauth)"
  set +e
  reauth_output="$(timeout 20 /opt/tailscale up --reset --force-reauth 2>&1)"
  reauth_rc=$?
  set -e
  log "force-reauth+reset rc=${reauth_rc}"
  if [[ -n "${reauth_output}" ]]; then
    printf '%s\n' "${reauth_output}" | tail -n 60
  fi
  status_json="$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')"
  backend_state="$(jq -r '.BackendState // "Unknown"' <<< "${status_json}" 2>/dev/null || echo "Unknown")"
  auth_url="$(jq -r '.AuthURL // .Self.AuthURL // empty' <<< "${status_json}" 2>/dev/null || true)"
fi

log "Final backend_state=${backend_state}"
if [[ -n "${auth_url}" ]]; then
  log "Final auth_url=${auth_url}"
fi

if [[ "${backend_state}" == "NeedsLogin" ]] || \
  [[ "${backend_state}" == "NeedsMachineAuth" ]] || \
  [[ "${backend_state}" == "Stopped" ]] || \
  [[ "${backend_state}" == "NoState" ]] || \
  [[ -n "${auth_url}" ]];
then
  exit 0
fi
exit 1
