#!/command/with-contenv bashio
# shellcheck shell=bash
set -euo pipefail

action="status"
case "${QUERY_STRING:-}" in
  *action=reconnect*) action="reconnect" ;;
  *action=logout*) action="logout" ;;
  *action=dnsdiag*) action="dnsdiag" ;;
  *action=diag*) action="diag" ;;
  *action=status*) action="status" ;;
esac

if [[ "${REQUEST_METHOD:-GET}" != "POST" ]] && [[ "${REQUEST_METHOD:-GET}" != "GET" ]]; then
  echo "Status: 405 Method Not Allowed"
  echo "Content-Type: application/json"
  echo
  echo '{"ok":false,"error":"method_not_allowed"}'
  exit 0
fi

run_action() {
  local cmd_output rc
  case "${action}" in
    reconnect)
      set +e
      cmd_output="$(timeout 25 /opt/tailscale up 2>&1)"
      rc=$?
      set -e
      ;;
    logout)
      set +e
      local tmp_output
      local down_rc prefs_pre_rc local_logout_rc cli_logout_rc kill_rc reset_state_rc prefs_post_rc
      local reauth_rc
      local daemon_pid logout_ok
      local status_after_reset_json state_after_reset auth_after_reset
      local status_after_reauth_json state_after_reauth auth_after_reauth
      local reauth_output reauth_auth_url
      tmp_output="$(mktemp)"
      down_rc=1
      prefs_pre_rc=1
      local_logout_rc=1
      cli_logout_rc=1
      kill_rc=0
      reset_state_rc=1
      prefs_post_rc=1
      reauth_rc=1
      logout_ok=false
      status_after_reset_json='{}'
      state_after_reset="Unknown"
      auth_after_reset=""
      status_after_reauth_json='{}'
      state_after_reauth="Unknown"
      auth_after_reauth=""
      reauth_output=""
      reauth_auth_url=""
      {
        echo "[logout] hard identity reset start"
        echo "[logout] tailscale down"
        timeout 20 /opt/tailscale down
        down_rc=$?
        echo "[logout] tailscale down rc=${down_rc}"

        echo "[logout] localapi prefs WantRunning=false (pre-reset)"
        timeout 10 curl -sS --max-time 8 --unix-socket /var/run/tailscale/tailscaled.sock \
          -X PATCH \
          -H "Content-Type: application/json" \
          --data '{"WantRunning":false}' \
          http://local-tailscaled.sock/localapi/v0/prefs
        prefs_pre_rc=$?
        echo "[logout] prefs pre-reset rc=${prefs_pre_rc}"

        echo "[logout] localapi /localapi/v0/logout"
        timeout 15 curl -sS --max-time 12 --unix-socket /var/run/tailscale/tailscaled.sock \
          -X POST http://local-tailscaled.sock/localapi/v0/logout
        local_logout_rc=$?
        echo "[logout] localapi logout rc=${local_logout_rc}"

        echo "[logout] tailscale logout"
        timeout 20 /opt/tailscale logout
        cli_logout_rc=$?
        echo "[logout] tailscale logout rc=${cli_logout_rc}"

        daemon_pid="$(ps -eo pid,comm | awk '$2==\"tailscaled\"{print $1; exit}')"
        if [[ -n "${daemon_pid}" ]]; then
          echo "[logout] stopping tailscaled pid=${daemon_pid}"
          kill "${daemon_pid}"
          kill_rc=$?
        else
          echo "[logout] tailscaled pid not found"
          kill_rc=0
        fi
        echo "[logout] kill rc=${kill_rc}"

        sleep 1
        echo "[logout] removing local auth/state files"
        rm -f /data/tailscaled.state
        rm -rf /data/state
        mkdir -p /data/state
        chmod 0700 /data/state
        reset_state_rc=$?
        echo "[logout] state reset rc=${reset_state_rc}"

        echo "[logout] waiting for s6 restart"
        sleep 2

        echo "[logout] localapi prefs WantRunning=false (post-reset)"
        timeout 10 curl -sS --max-time 8 --unix-socket /var/run/tailscale/tailscaled.sock \
          -X PATCH \
          -H "Content-Type: application/json" \
          --data '{"WantRunning":false}' \
          http://local-tailscaled.sock/localapi/v0/prefs
        prefs_post_rc=$?
        echo "[logout] prefs post-reset rc=${prefs_post_rc}"

        status_after_reset_json=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')
        state_after_reset="$(jq -r '.BackendState // "Unknown"' <<< "${status_after_reset_json}" 2>/dev/null || echo "Unknown")"
        auth_after_reset="$(jq -r '.AuthURL // .Self.AuthURL // empty' <<< "${status_after_reset_json}" 2>/dev/null || true)"
        echo "[logout] state after reset=${state_after_reset}"

        # If reset still leaves backend running, force an interactive reauth.
        if [[ "${state_after_reset}" == "Running" ]] || \
          [[ "${state_after_reset}" == "Unknown" ]] || \
          [[ -z "${auth_after_reset}" ]];
        then
          echo "[logout] forcing reauth via tailscale up --force-reauth"
          reauth_output="$(timeout 30 /opt/tailscale up --force-reauth 2>&1)"
          reauth_rc=$?
          echo "[logout] force-reauth rc=${reauth_rc}"
          if [[ -n "${reauth_output}" ]]; then
            echo "${reauth_output}"
          fi
          reauth_auth_url="$(grep -Eo 'https://login\.tailscale\.com/[[:alnum:]/._-]+' <<< "${reauth_output}" | head -n1 || true)"
        fi

        status_after_reauth_json=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')
        state_after_reauth="$(jq -r '.BackendState // "Unknown"' <<< "${status_after_reauth_json}" 2>/dev/null || echo "Unknown")"
        auth_after_reauth="$(jq -r '.AuthURL // .Self.AuthURL // empty' <<< "${status_after_reauth_json}" 2>/dev/null || true)"
        echo "[logout] state after reauth=${state_after_reauth}"

        # Consider reset requested only if we could clear persisted state and
        # drive backend into interactive login.
        if (( reset_state_rc == 0 )) && \
          { (( local_logout_rc == 0 )) || (( cli_logout_rc == 0 )); } && \
          {
            [[ "${state_after_reauth}" == "NeedsLogin" ]] || \
            [[ "${state_after_reauth}" == "NeedsMachineAuth" ]] || \
            [[ "${state_after_reauth}" == "Stopped" ]] || \
            [[ "${state_after_reauth}" == "NoState" ]] || \
            [[ -n "${auth_after_reauth}" ]] || \
            [[ -n "${reauth_auth_url}" ]];
          };
        then
          logout_ok=true
          echo "[logout] hard identity reset requested"
        else
          logout_ok=false
          echo "[logout] hard identity reset failed"
        fi
      } > "${tmp_output}" 2>&1
      cmd_output="$(cat "${tmp_output}")"
      rm -f "${tmp_output}"
      if [[ "${logout_ok}" == "true" ]]; then
        rc=0
      else
        rc=1
      fi
      set -e
      ;;
    diag|dnsdiag)
      cmd_output=""
      rc=0
      ;;
    *)
      cmd_output=""
      rc=0
      ;;
  esac
  ACTION_OUTPUT="${cmd_output}"
  ACTION_RC="${rc}"
}

json_bool() {
  if [[ "${1:-false}" == "true" ]]; then
    echo "true"
  else
    echo "false"
  fi
}

log_control_action() {
  if [[ "${action}" == "status" ]]; then
    return
  fi
  # Write operational traces to the add-on log without polluting CGI stdout.
  printf '%s control-api: %s\n' "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" "${1}" > /proc/1/fd/1 2>/dev/null || \
    printf '%s control-api: %s\n' "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" "${1}" >&2 || true
}

run_dns_checks=false
run_control_probe=false
if [[ "${action}" == "diag" ]] || [[ "${action}" == "dnsdiag" ]]; then
  run_dns_checks=true
fi
if [[ "${action}" == "diag" ]]; then
  run_control_probe=true
fi

log_control_action "request action=${action} method=${REQUEST_METHOD:-GET}"

run_action
status_json=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')
backend_state="$(jq -r '.BackendState // "Unknown"' <<< "${status_json}" 2>/dev/null || echo "Unknown")"
auth_url="$(jq -r '.AuthURL // .Self.AuthURL // empty' <<< "${status_json}" 2>/dev/null || true)"
online="$(jq -r '.Self.Online // false' <<< "${status_json}" 2>/dev/null || echo "false")"
dns_name="$(jq -r '.Self.DNSName // empty' <<< "${status_json}" 2>/dev/null || true)"
tailnet="$(jq -r '.CurrentTailnet.Name // empty' <<< "${status_json}" 2>/dev/null || true)"
output_trimmed="$(printf '%s' "${ACTION_OUTPUT}" | tail -c 2000)"

# After a hard identity reset, give tailscaled a few seconds to converge into
# a login-required state so the UI can render the new auth flow immediately.
if [[ "${action}" == "logout" ]]; then
  logout_deadline=$((SECONDS + 20))
  while (( SECONDS < logout_deadline )); do
    candidate_json=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')
    candidate_state="$(jq -r '.BackendState // "Unknown"' <<< "${candidate_json}" 2>/dev/null || echo "Unknown")"
    if [[ "${candidate_state}" == "NeedsLogin" ]] || \
      [[ "${candidate_state}" == "NeedsMachineAuth" ]] || \
      [[ "${candidate_state}" == "Stopped" ]] || \
      [[ "${candidate_state}" == "NoState" ]];
    then
      status_json="${candidate_json}"
      backend_state="${candidate_state}"
      auth_url="$(jq -r '.AuthURL // .Self.AuthURL // empty' <<< "${status_json}" 2>/dev/null || true)"
      online="$(jq -r '.Self.Online // false' <<< "${status_json}" 2>/dev/null || echo "false")"
      dns_name="$(jq -r '.Self.DNSName // empty' <<< "${status_json}" 2>/dev/null || true)"
      tailnet="$(jq -r '.CurrentTailnet.Name // empty' <<< "${status_json}" 2>/dev/null || true)"
      break
    fi
    sleep 1
  done
fi
login_server="$(bashio::config "login_server" "https://controlplane.tailscale.com")"
socket_ok=false
webui_ok=false
control_ok=false
webui_http_code="000"
dns_target="login.tailscale.com"
dns_resolvers_json='[]'
dns_any_ok=false
dns_all_ok=false
dns_count=0
if [[ -S /var/run/tailscale/tailscaled.sock ]]; then
  socket_ok=true
fi
webui_http_code="$(curl -sS --max-time 1 -o /dev/null -w "%{http_code}" "http://127.0.0.1:25899/" 2>/dev/null || echo "000")"
if [[ "${webui_http_code}" =~ ^(2[0-9][0-9]|3[0-9][0-9]|401|403)$ ]]; then
  webui_ok=true
fi
if [[ "${run_control_probe}" == "true" ]]; then
  if curl -fsS --max-time 2 "${login_server}" > /dev/null 2>&1; then
    control_ok=true
  fi
fi

declare -a dns_resolvers=()
if [[ "${run_dns_checks}" == "true" ]]; then
  while read -r _ resolver_ip
  do
    if [[ -n "${resolver_ip:-}" ]]; then
      dns_resolvers+=("${resolver_ip}")
    fi
  done < <(grep -E '^[[:space:]]*nameserver[[:space:]]+' /etc/resolv.conf 2>/dev/null || true)

  if (( ${#dns_resolvers[@]} == 0 )); then
    dns_resolvers=("100.100.100.100")
  fi

  declare -i dns_ok_count=0
  for resolver in "${dns_resolvers[@]}"
  do
    transport_ok=false
    query_ok=false
    if timeout 2 ping -c 1 -W 1 "${resolver}" > /dev/null 2>&1; then
      transport_ok=true
    fi
    if command -v nslookup > /dev/null 2>&1; then
      if timeout 3 nslookup "${dns_target}" "${resolver}" > /dev/null 2>&1; then
        query_ok=true
      fi
    elif command -v getent > /dev/null 2>&1; then
      if timeout 3 getent hosts "${dns_target}" > /dev/null 2>&1; then
        query_ok=true
      fi
    fi

    if [[ "${query_ok}" == "true" ]]; then
      dns_ok_count=$((dns_ok_count + 1))
    fi
    resolver_row="$(jq -nc \
      --arg resolver "${resolver}" \
      --argjson transport_ok "$(json_bool "${transport_ok}")" \
      --argjson dns_query_ok "$(json_bool "${query_ok}")" \
      '{resolver:$resolver, transport_ok:$transport_ok, dns_query_ok:$dns_query_ok}')"
    dns_resolvers_json="$(jq -c --argjson row "${resolver_row}" '. + [$row]' <<< "${dns_resolvers_json}")"
  done

  dns_count=${#dns_resolvers[@]}
  if (( dns_ok_count > 0 )); then
    dns_any_ok=true
  fi
  if (( dns_count > 0 )) && (( dns_ok_count == dns_count )); then
    dns_all_ok=true
  fi
fi

health_score=0
if [[ "${backend_state}" == "Running" ]]; then
  health_score=$((health_score + 55))
elif [[ "${backend_state}" == "NeedsLogin" ]] || [[ "${backend_state}" == "NeedsMachineAuth" ]]; then
  health_score=$((health_score + 25))
fi
if [[ "${online}" == "true" ]]; then
  health_score=$((health_score + 20))
fi
if [[ "${webui_ok}" == "true" ]]; then
  health_score=$((health_score + 15))
fi
if [[ "${control_ok}" == "true" ]]; then
  health_score=$((health_score + 5))
fi
if [[ "${dns_any_ok}" == "true" ]]; then
  health_score=$((health_score + 5))
fi
if [[ "${dns_all_ok}" == "true" ]]; then
  health_score=$((health_score + 5))
fi
if [[ "${backend_state}" == "Running" ]] && [[ "${online}" == "true" ]] && (( health_score < 65 )); then
  health_score=65
fi
if (( health_score > 100 )); then
  health_score=100
fi

ok="true"
if (( ACTION_RC != 0 )); then
  # Reconnect can return non-zero while still resulting in login-required transitional states.
  if [[ "${action}" == "reconnect" ]] && { [[ "${backend_state}" == "NeedsLogin" ]] || [[ "${backend_state}" == "NeedsMachineAuth" ]] || [[ "${backend_state}" == "Running" ]]; }; then
    ok="true"
  else
    ok="false"
  fi
fi
if [[ "${action}" == "logout" ]] && \
  [[ "${backend_state}" != "NeedsLogin" ]] && \
  [[ "${backend_state}" != "NeedsMachineAuth" ]] && \
  [[ "${backend_state}" != "Stopped" ]] && \
  [[ "${backend_state}" != "NoState" ]] && \
  [[ -z "${auth_url}" ]];
then
  ok="false"
fi

log_control_action "response action=${action} rc=${ACTION_RC} ok=${ok} backend=${backend_state} online=${online}"

if [[ "${ok}" == "true" ]]; then
  echo "Status: 200 OK"
else
  echo "Status: 400 Bad Request"
fi
echo "Content-Type: application/json"
echo "Cache-Control: no-store"
echo

jq -nc \
  --arg action "${action}" \
  --arg backend_state "${backend_state}" \
  --arg auth_url "${auth_url}" \
  --arg online "${online}" \
  --arg dns_name "${dns_name}" \
  --arg tailnet "${tailnet}" \
  --arg login_server "${login_server}" \
  --arg socket_ok "${socket_ok}" \
  --arg webui_ok "${webui_ok}" \
  --arg control_ok "${control_ok}" \
  --arg output "${output_trimmed}" \
  --arg dns_target "${dns_target}" \
  --argjson dns_resolvers "${dns_resolvers_json}" \
  --argjson dns_resolver_count "${dns_count}" \
  --argjson dns_any_ok "$(json_bool "${dns_any_ok}")" \
  --argjson dns_all_ok "$(json_bool "${dns_all_ok}")" \
  --argjson health_score "${health_score}" \
  --argjson rc "${ACTION_RC}" \
  --argjson ok "$(json_bool "${ok}")" \
  '{
    ok: $ok,
    action: $action,
    rc: $rc,
    backend_state: $backend_state,
    auth_url: $auth_url,
    self_online: ($online == "true"),
    self_dns_name: $dns_name,
    tailnet: $tailnet,
    login_server: $login_server,
    health_score: $health_score,
    checks: {
      tailscaled_socket: ($socket_ok == "true"),
      webui_local: ($webui_ok == "true"),
      control_plane_reachable: ($control_ok == "true"),
      dns_any_resolver_ok: $dns_any_ok,
      dns_all_resolvers_ok: $dns_all_ok
    },
    dns: {
      target: $dns_target,
      resolver_count: $dns_resolver_count,
      any_resolver_ok: $dns_any_ok,
      all_resolvers_ok: $dns_all_ok,
      resolvers: $dns_resolvers
    },
    output: $output
  }'
