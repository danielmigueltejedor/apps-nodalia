#!/command/with-contenv bashio
# shellcheck shell=bash
set -euo pipefail

action="status"
case "${QUERY_STRING:-}" in
  *action=reconnect*) action="reconnect" ;;
  *action=logout*) action="logout" ;;
  *action=dnsdiag*) action="dnsdiag" ;;
  *action=diag*) action="diag" ;;
  *action=status*) action="status" ;;
esac

if [[ "${REQUEST_METHOD:-GET}" != "POST" ]] && [[ "${action}" != "status" ]]; then
  echo "Status: 405 Method Not Allowed"
  echo "Content-Type: application/json"
  echo
  echo '{"ok":false,"error":"method_not_allowed"}'
  exit 0
fi

run_action() {
  local cmd_output rc
  case "${action}" in
    reconnect)
      set +e
      cmd_output="$(timeout 25 /opt/tailscale up 2>&1)"
      rc=$?
      set -e
      ;;
    logout)
      set +e
      cmd_output="$(
        {
          echo "[logout] tailscale down"
          timeout 20 /opt/tailscale down
          echo "[logout] tailscale logout"
          timeout 20 /opt/tailscale logout
        } 2>&1
      )"
      rc=$?
      set -e
      ;;
    diag|dnsdiag)
      cmd_output=""
      rc=0
      ;;
    *)
      cmd_output=""
      rc=0
      ;;
  esac
  ACTION_OUTPUT="${cmd_output}"
  ACTION_RC="${rc}"
}

json_bool() {
  if [[ "${1:-false}" == "true" ]]; then
    echo "true"
  else
    echo "false"
  fi
}

run_action
status_json=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')
backend_state="$(jq -r '.BackendState // "Unknown"' <<< "${status_json}" 2>/dev/null || echo "Unknown")"
auth_url="$(jq -r '.AuthURL // .Self.AuthURL // empty' <<< "${status_json}" 2>/dev/null || true)"
online="$(jq -r '.Self.Online // false' <<< "${status_json}" 2>/dev/null || echo "false")"
dns_name="$(jq -r '.Self.DNSName // empty' <<< "${status_json}" 2>/dev/null || true)"
tailnet="$(jq -r '.CurrentTailnet.Name // empty' <<< "${status_json}" 2>/dev/null || true)"
output_trimmed="$(printf '%s' "${ACTION_OUTPUT}" | tail -c 800)"

# Force logout path: if it still stays Running, clear local state and restart tailscaled.
if [[ "${action}" == "logout" ]] && [[ "${backend_state}" == "Running" ]]; then
  set +e
  force_output="$(
    {
      echo "[force] backend still Running, applying hard logout fallback"
      echo "[force] tailscale down"
      /opt/tailscale down
      daemon_pid="$(ps -eo pid,comm | awk '$2==\"tailscaled\"{print $1; exit}')"
      if [[ -n "${daemon_pid}" ]]; then
        echo "[force] stopping tailscaled pid=${daemon_pid}"
        kill "${daemon_pid}"
      else
        echo "[force] tailscaled pid not found"
      fi
      sleep 1
      echo "[force] removing local state files"
      rm -f /data/tailscaled.state
      rm -rf /data/state
      mkdir -p /data/state
      chmod 0700 /data/state
      echo "[force] waiting for s6 restart"
      sleep 2
      echo "[force] post-restart logout probe"
      timeout 15 /opt/tailscale logout || true
    } 2>&1
  )"
  force_rc=$?
  set -e
  ACTION_OUTPUT="${ACTION_OUTPUT}"$'\n'"${force_output}"
  if (( ACTION_RC == 0 )) && (( force_rc != 0 )); then
    ACTION_RC=${force_rc}
  fi
  status_json=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null || echo '{}')
  backend_state="$(jq -r '.BackendState // "Unknown"' <<< "${status_json}" 2>/dev/null || echo "Unknown")"
  auth_url="$(jq -r '.AuthURL // .Self.AuthURL // empty' <<< "${status_json}" 2>/dev/null || true)"
  online="$(jq -r '.Self.Online // false' <<< "${status_json}" 2>/dev/null || echo "false")"
  dns_name="$(jq -r '.Self.DNSName // empty' <<< "${status_json}" 2>/dev/null || true)"
  tailnet="$(jq -r '.CurrentTailnet.Name // empty' <<< "${status_json}" 2>/dev/null || true)"
  output_trimmed="$(printf '%s' "${ACTION_OUTPUT}" | tail -c 1200)"
fi
login_server="$(bashio::config "login_server" "https://controlplane.tailscale.com")"
socket_ok=false
webui_ok=false
control_ok=false
webui_http_code="000"
dns_target="login.tailscale.com"
dns_resolvers_json='[]'
dns_any_ok=false
dns_all_ok=false
dns_count=0
if [[ -S /var/run/tailscale/tailscaled.sock ]]; then
  socket_ok=true
fi
webui_http_code="$(curl -sS --max-time 1 -o /dev/null -w "%{http_code}" "http://127.0.0.1:25899/" 2>/dev/null || echo "000")"
if [[ "${webui_http_code}" =~ ^(2[0-9][0-9]|3[0-9][0-9]|401|403)$ ]]; then
  webui_ok=true
fi
if curl -fsS --max-time 2 "${login_server}" > /dev/null 2>&1; then
  control_ok=true
fi

declare -a dns_resolvers=()
while read -r _ resolver_ip
do
  if [[ -n "${resolver_ip:-}" ]]; then
    dns_resolvers+=("${resolver_ip}")
  fi
done < <(grep -E '^[[:space:]]*nameserver[[:space:]]+' /etc/resolv.conf 2>/dev/null || true)

if (( ${#dns_resolvers[@]} == 0 )); then
  dns_resolvers=("100.100.100.100")
fi

declare -i dns_ok_count=0
for resolver in "${dns_resolvers[@]}"
do
  transport_ok=false
  query_ok=false
  if timeout 2 ping -c 1 -W 1 "${resolver}" > /dev/null 2>&1; then
    transport_ok=true
  fi
  if command -v nslookup > /dev/null 2>&1; then
    if timeout 3 nslookup "${dns_target}" "${resolver}" > /dev/null 2>&1; then
      query_ok=true
    fi
  elif command -v getent > /dev/null 2>&1; then
    if timeout 3 getent hosts "${dns_target}" > /dev/null 2>&1; then
      query_ok=true
    fi
  fi

  if [[ "${query_ok}" == "true" ]]; then
    dns_ok_count=$((dns_ok_count + 1))
  fi
  resolver_row="$(jq -nc \
    --arg resolver "${resolver}" \
    --argjson transport_ok "$(json_bool "${transport_ok}")" \
    --argjson dns_query_ok "$(json_bool "${query_ok}")" \
    '{resolver:$resolver, transport_ok:$transport_ok, dns_query_ok:$dns_query_ok}')"
  dns_resolvers_json="$(jq -c --argjson row "${resolver_row}" '. + [$row]' <<< "${dns_resolvers_json}")"
done

dns_count=${#dns_resolvers[@]}
if (( dns_ok_count > 0 )); then
  dns_any_ok=true
fi
if (( dns_count > 0 )) && (( dns_ok_count == dns_count )); then
  dns_all_ok=true
fi

health_score=0
if [[ "${backend_state}" == "Running" ]]; then
  health_score=$((health_score + 55))
elif [[ "${backend_state}" == "NeedsLogin" ]] || [[ "${backend_state}" == "NeedsMachineAuth" ]]; then
  health_score=$((health_score + 25))
fi
if [[ "${online}" == "true" ]]; then
  health_score=$((health_score + 20))
fi
if [[ "${webui_ok}" == "true" ]]; then
  health_score=$((health_score + 15))
fi
if [[ "${control_ok}" == "true" ]]; then
  health_score=$((health_score + 5))
fi
if [[ "${dns_any_ok}" == "true" ]]; then
  health_score=$((health_score + 5))
fi
if [[ "${dns_all_ok}" == "true" ]]; then
  health_score=$((health_score + 5))
fi
if [[ "${backend_state}" == "Running" ]] && [[ "${online}" == "true" ]] && (( health_score < 65 )); then
  health_score=65
fi
if (( health_score > 100 )); then
  health_score=100
fi

ok="true"
if (( ACTION_RC != 0 )); then
  # Reconnect can return non-zero while still resulting in login-required transitional states.
  if [[ "${action}" == "reconnect" ]] && { [[ "${backend_state}" == "NeedsLogin" ]] || [[ "${backend_state}" == "NeedsMachineAuth" ]] || [[ "${backend_state}" == "Running" ]]; }; then
    ok="true"
  else
    ok="false"
  fi
fi
if [[ "${action}" == "logout" ]] && \
  [[ "${backend_state}" != "NeedsLogin" ]] && \
  [[ "${backend_state}" != "NeedsMachineAuth" ]] && \
  [[ "${backend_state}" != "Stopped" ]] && \
  [[ "${backend_state}" != "NoState" ]];
then
  ok="false"
fi

if [[ "${ok}" == "true" ]]; then
  echo "Status: 200 OK"
else
  echo "Status: 400 Bad Request"
fi
echo "Content-Type: application/json"
echo "Cache-Control: no-store"
echo

jq -nc \
  --arg action "${action}" \
  --arg backend_state "${backend_state}" \
  --arg auth_url "${auth_url}" \
  --arg online "${online}" \
  --arg dns_name "${dns_name}" \
  --arg tailnet "${tailnet}" \
  --arg login_server "${login_server}" \
  --arg socket_ok "${socket_ok}" \
  --arg webui_ok "${webui_ok}" \
  --arg control_ok "${control_ok}" \
  --arg output "${output_trimmed}" \
  --arg dns_target "${dns_target}" \
  --argjson dns_resolvers "${dns_resolvers_json}" \
  --argjson dns_resolver_count "${dns_count}" \
  --argjson dns_any_ok "$(json_bool "${dns_any_ok}")" \
  --argjson dns_all_ok "$(json_bool "${dns_all_ok}")" \
  --argjson health_score "${health_score}" \
  --argjson rc "${ACTION_RC}" \
  --argjson ok "$(json_bool "${ok}")" \
  '{
    ok: $ok,
    action: $action,
    rc: $rc,
    backend_state: $backend_state,
    auth_url: $auth_url,
    self_online: ($online == "true"),
    self_dns_name: $dns_name,
    tailnet: $tailnet,
    login_server: $login_server,
    health_score: $health_score,
    checks: {
      tailscaled_socket: ($socket_ok == "true"),
      webui_local: ($webui_ok == "true"),
      control_plane_reachable: ($control_ok == "true"),
      dns_any_resolver_ok: $dns_any_ok,
      dns_all_resolvers_ok: $dns_all_ok
    },
    dns: {
      target: $dns_target,
      resolver_count: $dns_resolver_count,
      any_resolver_ok: $dns_any_ok,
      all_resolvers_ok: $dns_all_ok,
      resolvers: $dns_resolvers
    },
    output: $output
  }'
