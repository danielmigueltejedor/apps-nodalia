#!/command/with-contenv bashio
# shellcheck shell=bash
# ==============================================================================
# Home Assistant Community Add-on: Tailscale
# Runs tailscale web interface
# ==============================================================================
declare -a options
declare backend_state
declare -i wait_counter=0

readonly WAIT_DELAY=2
readonly WAIT_MAX=60  # 60*2s = 120s

bashio::log.info 'Starting Tailscale web...'

# Get random port
options+=(--listen 127.0.0.1:25899)

# Use readonly webui mode by default; allow opting out for full control (e.g. logout)
if ! bashio::config.has_value "webui_readonly" || bashio::config.true "webui_readonly"; then
  options+=(--readonly)
  bashio::log.info 'Tailscale web UI started in readonly mode'
else
  bashio::log.warning 'Tailscale web UI started in full-control mode (readonly disabled)'
fi

# Avoid starting web too early while backend is still booting.
# In that race, Tailscale can keep serving the "unavailable" banner indefinitely.
while true
do
  backend_state=$(/opt/tailscale status --json --self=true --peers=false 2>/dev/null \
    | jq -r '.BackendState // "Unknown"' 2>/dev/null || echo "Unknown")
  if [[ "${backend_state}" != "NoState" ]] && [[ "${backend_state}" != "Starting" ]] && [[ "${backend_state}" != "Unknown" ]]; then
    break
  fi
  if (( wait_counter >= WAIT_MAX )); then
    bashio::log.warning \
      "Tailscale web preflight timeout; backend still ${backend_state}." \
      "Starting web anyway."
    break
  fi
  wait_counter=$((wait_counter + 1))
  sleep "${WAIT_DELAY}"
done
bashio::log.info "Tailscale web preflight state: ${backend_state}"

# Run Tailscale
exec /opt/tailscale --socket=/var/run/tailscale/tailscaled.sock web "${options[@]}"
