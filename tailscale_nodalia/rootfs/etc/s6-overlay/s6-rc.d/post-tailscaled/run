#!/command/with-contenv bashio
# shellcheck shell=bash
# ==============================================================================
# Home Assistant Community Add-on: Tailscale
# Runs after the machine has been logged in into the Tailscale network
# ==============================================================================
declare interface
declare -a options
declare -a routes=()
declare route
declare -a colliding_routes=()
declare login_server
declare tags
declare keyexpiry
declare setup_profile
declare wait_counter=0
declare backend_state
declare self_addresses
declare userspace_mode
declare accept_dns_enabled
declare accept_routes_enabled
declare advertise_exit_node_enabled
declare advertise_connector_enabled
declare stateful_filtering_enabled
declare snat_subnet_routes_enabled
declare userspace_networking_enabled
declare advertise_routes_count
declare status_json
declare auth_url
declare notification_payload
declare onboarding_payload
declare up_output
declare up_rc

readonly WAIT_DELAY=2
readonly WAIT_RUNNING_COUNT=45   # 45*2s = 90s
readonly LOGIN_NOTIFICATION_ID="tailscale_nodalia_login_required"
readonly ONBOARDING_STATE_FILE="/data/tailscale-onboarding.json"
readonly TAILSCALE_UP_TIMEOUT=45

write_onboarding_state() {
  local state needs_login url now
  state="${1:-Unknown}"
  needs_login="${2:-false}"
  url="${3:-}"
  now="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

  onboarding_payload=$(jq -nc \
    --arg backend_state "${state}" \
    --arg auth_url "${url}" \
    --arg updated_at "${now}" \
    --argjson needs_login "${needs_login}" \
    '{backend_state:$backend_state, needs_login:$needs_login, auth_url:$auth_url, updated_at:$updated_at}')

  printf '%s\n' "${onboarding_payload}" > "${ONBOARDING_STATE_FILE}"
}

notify_login_required() {
  local url message
  url="${1:-}"
  message="Tailscale necesita inicio de sesion en esta aplicacion.\n\nAbre la pagina de onboarding en la Web UI: /onboarding"
  if bashio::var.has_value "${url}"; then
    message="${message}\n\nURL directa de login:\n${url}"
  fi

  notification_payload=$(jq -nc \
    --arg title "Tailscale (Nodalia): login requerido" \
    --arg message "${message}" \
    --arg notification_id "${LOGIN_NOTIFICATION_ID}" \
    '{title:$title, message:$message, notification_id:$notification_id}')

  if ! bashio::api.supervisor POST "/core/api/services/persistent_notification/create" "${notification_payload}" \
    > /dev/null 2>&1
  then
    bashio::log.warning "Unable to create Home Assistant persistent notification for login onboarding"
  fi
}

dismiss_login_notification() {
  notification_payload=$(jq -nc \
    --arg notification_id "${LOGIN_NOTIFICATION_ID}" \
    '{notification_id:$notification_id}')

  if ! bashio::api.supervisor POST "/core/api/services/persistent_notification/dismiss" "${notification_payload}" \
    > /dev/null 2>&1
  then
    bashio::log.debug "Persistent login notification not dismissed (it may not exist yet)"
  fi
}

# Default options
options+=(--hostname "$(bashio::info.hostname)")

# Setup profile (non-breaking: custom keeps current behavior)
setup_profile="$(bashio::config "setup_profile" "custom")"

# Effective booleans based on current behavior defaults
accept_dns_enabled=false
if ! bashio::config.has_value "accept_dns" || bashio::config.true "accept_dns"; then
  accept_dns_enabled=true
fi

accept_routes_enabled=false
if ! bashio::config.has_value "accept_routes" || bashio::config.true "accept_routes"; then
  accept_routes_enabled=true
fi

advertise_exit_node_enabled=false
if ! bashio::config.has_value "advertise_exit_node" || bashio::config.true "advertise_exit_node"; then
  advertise_exit_node_enabled=true
fi

advertise_connector_enabled=false
if ! bashio::config.has_value "advertise_connector" || bashio::config.true "advertise_connector"; then
  advertise_connector_enabled=true
fi

stateful_filtering_enabled=false
if bashio::config.has_value "stateful_filtering" && bashio::config.true "stateful_filtering"; then
  stateful_filtering_enabled=true
fi

snat_subnet_routes_enabled=false
if ! bashio::config.has_value "snat_subnet_routes" || bashio::config.true "snat_subnet_routes"; then
  snat_subnet_routes_enabled=true
fi

userspace_networking_enabled=false
if ! bashio::config.has_value "userspace_networking" || bashio::config.true "userspace_networking"; then
  userspace_networking_enabled=true
fi

# Apply non-breaking profile overrides (only when a profile is explicitly selected)
case "${setup_profile}" in
  home_access)
    accept_dns_enabled=true
    accept_routes_enabled=false
    advertise_exit_node_enabled=false
    advertise_connector_enabled=false
    stateful_filtering_enabled=false
    snat_subnet_routes_enabled=true
    userspace_networking_enabled=false
    bashio::log.info "Applying setup_profile=home_access"
    ;;
  subnet_router)
    accept_dns_enabled=true
    accept_routes_enabled=true
    advertise_exit_node_enabled=false
    advertise_connector_enabled=false
    stateful_filtering_enabled=false
    snat_subnet_routes_enabled=true
    userspace_networking_enabled=false
    bashio::log.info "Applying setup_profile=subnet_router"
    ;;
  exit_node)
    accept_dns_enabled=true
    accept_routes_enabled=false
    advertise_exit_node_enabled=true
    advertise_connector_enabled=false
    stateful_filtering_enabled=false
    snat_subnet_routes_enabled=true
    userspace_networking_enabled=false
    bashio::log.info "Applying setup_profile=exit_node"
    ;;
  *)
    ;;
esac

# Accept magicDNS by default when not set, or when explicitly enabled
if bashio::var.true "${accept_dns_enabled}"; then
  options+=(--accept-dns)
else
  options+=(--accept-dns=false)
fi

# Accept routes by default when not set, or when explicitly enabled
if bashio::var.true "${accept_routes_enabled}"; then
  options+=(--accept-routes)
else
  options+=(--accept-routes=false)
fi

# Check exit node configuration
if bashio::var.true "${advertise_exit_node_enabled}" && \
  bashio::config.has_value "exit_node"
then
  bashio::exit.nok "You can't advertise this device as an exit node and at the same time specify an exit node to use"
fi

# Advertise as exit node by default when not set, or when explicitly enabled
if bashio::var.true "${advertise_exit_node_enabled}"; then
  options+=(--advertise-exit-node)
else
  options+=(--advertise-exit-node=false)
fi

# Use exit node when explicitly defined
if bashio::config.has_value "exit_node"; then
  options+=(--exit-node="$(bashio::config "exit_node")")
  # The exit-node-allow-lan-access=true is required to access the internal hassio and docker networks also, even when exit node is specified
  options+=(--exit-node-allow-lan-access=true)
else
  options+=(--exit-node=)
  options+=(--exit-node-allow-lan-access=false)
fi

# Advertise app connector by default when not set, or when explicitly enabled
if bashio::var.true "${advertise_connector_enabled}"; then
  options+=(--advertise-connector)
else
  options+=(--advertise-connector=false)
fi

# Get configured control server
if bashio::config.has_value "login_server";
then
  login_server=$(bashio::config "login_server")
  options+=(--login-server="${login_server}")
fi

# Enable stateful filtering (it's disabled by default from v1.66.4)
if bashio::var.true "${stateful_filtering_enabled}"; then
  options+=(--stateful-filtering)
else
  options+=(--stateful-filtering=false)
fi

# Support advanced site-to-site networking, disable source addresses NAT
if bashio::var.true "${snat_subnet_routes_enabled}"; then
  options+=(--snat-subnet-routes)
else
  options+=(--snat-subnet-routes=false)
fi

# Get configured tags
tags=$(bashio::config "tags//[] | join(\",\")" "")
options+=(--advertise-tags="${tags}")

# Advertise subnet routes
if bashio::var.equals "${setup_profile}" "subnet_router"; then
  advertise_routes_count="$(bashio::config "advertise_routes | length" "0")"
  if [[ "${advertise_routes_count}" == "0" ]]; then
    readarray -t routes < <(subnet-routes local)
  else
    readarray -t routes < <(subnet-routes advertised)
  fi
else
  readarray -t routes < <(subnet-routes advertised)
fi
IFS=","
options+=(--advertise-routes="${routes[*]}")
unset IFS

# Wait for the network to be available and logged in
while ! bashio::fs.socket_exists "/var/run/tailscale/tailscaled.sock" || \
  ! /opt/tailscale status --json --peers=false --self=false \
    | jq --exit-status '.BackendState == "Running" or .BackendState == "NeedsLogin" or .BackendState == "NeedsMachineAuth" or .BackendState == "Stopped"' > /dev/null;
do
  sleep 2
done

# Start Tailscale (bounded timeout to avoid hanging forever when login is required)
set +e
up_output="$(timeout "${TAILSCALE_UP_TIMEOUT}" /opt/tailscale up "${options[@]}" 2>&1)"
up_rc=$?
set -e

if (( up_rc != 0 )); then
  status_json=$(/opt/tailscale status --json --peers=false --self=false 2>/dev/null || true)
  backend_state=$(jq -r '.BackendState // "Unknown"' <<< "${status_json}" 2>/dev/null || echo "Unknown")
  if bashio::var.equals "${backend_state}" "NeedsLogin" || \
    bashio::var.equals "${backend_state}" "NeedsMachineAuth";
  then
    auth_url=$(jq -r '.AuthURL // .Self.AuthURL // empty' <<< "${status_json}" 2>/dev/null || true)
    if ! bashio::var.has_value "${auth_url}"; then
      auth_url=$(grep -Eo 'https://login\.tailscale\.com/[[:alnum:]/._-]+' <<< "${up_output}" | head -n1 || true)
    fi
    write_onboarding_state "${backend_state}" true "${auth_url}"
    notify_login_required "${auth_url}"
    bashio::log.notice \
      "Tailscale startup requires interactive login (${backend_state})." \
      "Open /onboarding in the app Web UI to continue."
  else
    bashio::exit.nok \
      "Unable to start up Tailscale (state: ${backend_state}, exit: ${up_rc})" \
      "${up_output}"
  fi
fi

# Wait for the network to become operational (Running) or explicitly require login.
while true
do
  status_json=$(/opt/tailscale status --json --peers=false --self=false 2>/dev/null || true)
  backend_state=$(jq -r '.BackendState // "Unknown"' <<< "${status_json}" 2>/dev/null || echo "Unknown")

  if bashio::var.equals "${backend_state}" "Running"; then
    auth_url=""
    write_onboarding_state "${backend_state}" false "${auth_url}"
    dismiss_login_notification
    bashio::log.info "Tailscale is running"
    break
  fi

  if bashio::var.equals "${backend_state}" "NeedsLogin" || \
    bashio::var.equals "${backend_state}" "NeedsMachineAuth";
  then
    auth_url=$(jq -r '.AuthURL // .Self.AuthURL // empty' <<< "${status_json}" 2>/dev/null || true)
    write_onboarding_state "${backend_state}" true "${auth_url}"
    notify_login_required "${auth_url}"
    bashio::log.notice \
      "Tailscale requires interactive login (${backend_state})." \
      "Open the app Web UI onboarding page at /onboarding to copy the login URL."
    break
  fi

  if (( wait_counter++ == WAIT_RUNNING_COUNT )); then
    write_onboarding_state "${backend_state}" false ""
    bashio::log.warning \
      "Timed out waiting for Tailscale to become ready (last state: ${backend_state})." \
      "Starting app in degraded mode so Web UI remains available."
    break
  fi
  sleep ${WAIT_DELAY}
done

# Emit an operational summary for troubleshooting.
if bashio::var.true "${userspace_networking_enabled}"; then
  userspace_mode="enabled"
else
  userspace_mode="disabled"
fi

self_addresses="$(/opt/tailscale ip -4 2>/dev/null || true)"
self_addresses="${self_addresses} $(/opt/tailscale ip -6 2>/dev/null || true)"
bashio::log.info \
  "Startup summary:" \
  "setup_profile=${setup_profile}," \
  "userspace_networking=${userspace_mode}," \
  "accept_routes=${accept_routes_enabled}," \
  "share_homeassistant=$(bashio::config "share_homeassistant" "disabled")," \
  "addresses=${self_addresses}"

if bashio::var.equals "${backend_state}" "Running"; then
  # Linux optimizations for subnet routers and exit nodes
  # Based on: https://tailscale.com/kb/1320/performance-best-practices#linux-optimizations-for-subnet-routers-and-exit-nodes
  # Note: Changes made via ethtool are not persistent and will be lost after the machine shuts down
  if interface=$( \
    curl -sf --unix-socket /var/run/tailscale/tailscaled.sock http://local-tailscaled.sock/localapi/v0/check-udp-gro-forwarding \
    | jq -rc '.Warning' \
    | sed -nr 's/^UDP GRO forwarding is suboptimally configured on (\S+),.*$/\1/p') \
    && bashio::var.has_value "${interface}";
  then
    bashio::log.info "Enabling UDP GRO for forwarding on ${interface}"
    if ! ethtool -K "${interface}" rx-udp-gro-forwarding on rx-gro-list off; then
      bashio::log.warning "Enabling UDP GRO failed"
    fi
  fi

  # Delete previously created persistent tailscale serve configuration ONCE
  # After the add-on's share-homeassistant (serve and funnel) service is a longrun service, we do not modify the serve state permanently
  # This step can be removed in a later version with the file in the data folder also
  if ! bashio::fs.file_exists "/data/final_serve_reset_is_done"; then
    if ! /opt/tailscale serve reset; then
      bashio::exit.nok "Unable to remove previous Tailscale Serve and Funnel settings"
    fi
    touch "/data/final_serve_reset_is_done"
  fi

  # Warn about key expiration
  if keyexpiry=$(/opt/tailscale status --self=true --peers=false --json | jq -rce '.Self.KeyExpiry'); then
    bashio::log.warning "The connection's key will expire on: ${keyexpiry}"
    bashio::log.warning "Consider disabling key expiry to avoid losing connection to your Home Assistant device."
    bashio::log.warning "Please check your configuration based on the add-on's documentation under \"Configuration\""
  fi

  # Warn about colliding subnet routes if non-userspace networking and accepting routes are enabled
  if bashio::var.false "${userspace_networking_enabled}" && \
    bashio::var.true "${accept_routes_enabled}";
  then
    readarray -t colliding_routes < <( \
      comm -1 -2 \
        <(subnet-routes local) \
        <(/opt/tailscale status --json --peers=true --self=false \
          | jq -rc '.Peer[] | select(has("PrimaryRoutes")) | .PrimaryRoutes[]' \
          | sort -u))
    if (( 0 < ${#colliding_routes[@]} )); then
      bashio::log.warning \
        "Currently the following subnets are both present as local subnets" \
        "and are also routed within your tailnet to other nodes!"
      bashio::log.warning \
        "Please reconfigure your subnet routing within your tailnet" \
        "to prevent current or future collisions."
    fi
    for route in "${colliding_routes[@]}"; do
      bashio::log.warning "  ${route}"
    done
  fi
else
  bashio::log.notice \
    "Startup completed in onboarding mode (${backend_state})." \
    "Complete login from /onboarding or from the persistent notification in Home Assistant."
fi

# Notify about userspace networking
if bashio::var.true "${userspace_networking_enabled}";
then
  bashio::log.notice \
    "The add-on uses userspace networking mode."
  bashio::log.notice \
    "If you need to access other clients on your tailnet from your Home Assistant instance," \
    "disable userspace networking mode, that will create a \"tailscale0\" network interface on your host."
  bashio::log.notice \
    "Please check your configuration based on the add-on's documentation under \"Option: userspace_networking\""
fi
